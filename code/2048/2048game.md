# 2048æ¸¸æˆ

Updated 1820 GMT+8 Dec 08 2025

2025 spring, Complied by Hongfei Yan



â€‹	é€‰æ‹©2048æ¸¸æˆä½œä¸ºæ•™å­¦æ¡ˆä¾‹ã€‚2048 æ¸¸æˆæ˜¯ 2014 å¹´ç”± Gabriele Cirulli æ¨å‡ºçš„å•äººæ•°å­—æ¸¸æˆã€‚è®¾è®¡ 2048 AI çš„ç®—æ³•æ€è·¯ä¸æŠ€å·§åœ¨æ¸¸æˆç®—æ³•è®¾è®¡ä¸­å¾ˆå…·æœ‰ä»£è¡¨æ€§ï¼Œä¸” 2048 æ¸¸æˆè§„åˆ™ç®€å•ï¼Œåœ¨æ¢ç´¢è§£æ³•çš„è¿‡ç¨‹ä¸­å……æ»¡è¶£å‘³æ€§ï¼Œæ˜¯ä¸€ä¸ªéå¸¸é€‚åˆä½œä¸ºè®¡ç®—æœºç§‘å­¦æ–¹é¢ç›¸å…³æ•™å­¦çš„ç›Šæ™ºæ¸¸æˆ ã€‚æœ¬èŠ‚ä»¥é—®é¢˜æ±‚è§£ä¸ºå¯¼å‘ï¼Œä»¥æµè¡Œçš„å•äººæ•°å­—æ¸¸æˆ 2048 çš„ AI ç®—æ³•è®¾è®¡é—®é¢˜ä¸ºä¸»çº¿ï¼Œè¯•å›¾åœ¨å‰–æé—®é¢˜ã€æå‡ºæ€è·¯ã€æ‹“å±•å»¶ä¼¸ç­‰å®Œæ•´çš„é—®é¢˜æ±‚è§£è¿‡ç¨‹ä¸­æ¿€å‘å­¦ä¹ è€…èƒ½åŠ¨æ€§ï¼Œä½¿å­¦ä¹ è€…å¯¹æ¸¸æˆ AI ç®—æ³•çš„è®¾è®¡æ€è·¯å’Œå¸¸è§ç®—æ³•è¾¾åˆ°è¾ƒé«˜çš„è®¤çŸ¥æ°´å¹³ã€‚

â€‹	2048 æ¸¸æˆç•Œé¢å¦‚å›¾5-23æ‰€ç¤ºï¼Œç©å®¶éœ€è¦åœ¨ $4\times4$ çš„æ•°å­—æ–¹æ ¼çŸ©é˜µä¸­åšä¸Šã€ä¸‹ã€å·¦ã€å³å››ä¸ªæ–¹å‘ä¹‹ä¸€çš„æ»‘åŠ¨æ“ä½œã€‚æ¯æ¬¡æ»‘åŠ¨æ“ä½œä¼šä½¿å¾—æ‰€æœ‰æ–¹å—å…¨éƒ¨æ²¿ç€æŸä¸ªæ–¹å‘æ»‘åŠ¨ç›´è‡³è¢«è¾¹ç•Œæˆ–å…¶ä»–æ–¹å—é˜»æŒ¡ã€‚å½“ä¸¤ä¸ªæ•°å­—æ–¹æ ¼ä¸­çš„æ•°å­—ç›¸åŒï¼Œä¸”æ»‘åŠ¨åä¸¤æ–¹æ ¼ç›¸é‚»ï¼Œåˆ™è¿™ä¸¤ä¸ªæ•°å­—æ–¹æ ¼ä¼šè¢«åˆå¹¶ä¸ºä¸€ä¸ªæ–¹æ ¼ï¼Œå…¶æ•°å­—ä¸ºåŸæ¥ä¸¤æ–¹å—ä¹‹å’Œï¼Œå¦‚å›¾5-24æ‰€ç¤ºã€‚æ‰§è¡Œä¸Šæ»‘æ“ä½œåï¼Œæœ€å·¦åˆ—çš„ä¸¤ä¸ª 2 åˆå¹¶ä¸º 4ï¼Œå¹¶ä¸Šç§»è‡³ç¬¬äºŒè¡Œï¼›å·¦æ•°ç¬¬ä¸‰åˆ—çš„ä¸Šæ–¹ä¸¤ä¸ªç›¸é‚» 8 åˆå¹¶ä¸º 16 å¹¶ä¸Šç§»ï¼›æœ€å³ä¸€è¡Œçš„ä¸Šä¸‹ä¸¤å¯¹ç›¸é‚»çš„ 2 å‡åˆå¹¶ä¸º 4ï¼Œå¹¶ä¸Šç§»è‡³ç¬¬1å’Œç¬¬ 2 è¡Œï¼Œè¿™ä¸€åˆ—å€¼å¾—æ³¨æ„çš„æ˜¯ï¼Œè¯¥æ¬¡æ“ä½œåˆå¹¶è¿‡çš„ä¸¤ä¸ªæ–¹å— 4 å¹¶ä¸ä¼šç»§ç»­åˆå¹¶ã€‚æ¯æ¬¡æ»‘åŠ¨æ“ä½œåï¼Œç³»ç»Ÿéšæœºåœ¨ä¸€ä¸ªæ²¡æœ‰æ•°å­—çš„æ–¹æ ¼ä¸­æŒ‰ç…§åˆ†åˆ« 90%ã€10% çš„æ¦‚ç‡éšæœºç”Ÿæˆ 2 æˆ– 4 ä¸¤ç§ä¹‹ä¸€çš„æ•°å­—æ–¹æ ¼ã€‚æ¸¸æˆçš„åˆå§‹å±€é¢ä¸ºåœ¨ç©ºæ£‹ç›˜ä¸ŠæŒ‰ä¸Šè¿°è§„åˆ™éšæœºç”Ÿæˆä¸¤ä¸ªæ–¹å—åçš„æ£‹ç›˜ã€‚æ¸¸æˆç›®æ ‡æ˜¯äº§ç”Ÿæ•°å­—å°½å¯èƒ½å¤§çš„æ–¹å—ã€‚ä¸ºä¾¿äºä¹‹åæµ‹è¯•ç®—æ³•æ•ˆç‡ï¼Œæœ¬ä¹¦è®¾è®¡çš„ 2048 æ¸¸æˆä»»åŠ¡æ— æ–¹å—æ•°å­—çš„ä¸Šé™ï¼Œè¾¾åˆ° 2048 åæ¸¸æˆä»ç„¶ç»§ç»­ï¼Œå½“ä¸”ä»…å½“å±€é¢æ— æ³•è¿›è¡Œä»»ä½•æ»‘åŠ¨æ“ä½œæ—¶æ¸¸æˆç»“æŸã€‚



<img src="https://raw.githubusercontent.com/GMyhf/img/main/img/image-20230109211246988.png" alt="image-20230109211246988" style="zoom:50%;" />

<center>å›¾ 2048 æ¸¸æˆåˆå§‹ç•Œé¢</center>



![image-20230109211322682](https://raw.githubusercontent.com/GMyhf/img/main/img/image-20230109211322682.png)

<center>å›¾ ä¸€æ¬¡å‘ä¸Šæ»‘åŠ¨ç¤ºæ„å›¾ï¼Œå³å›¾å·¦ä¸‹ä¾§çš„2ä¸ºç³»ç»Ÿç”Ÿæˆçš„æ–°æ–¹å—</center>



â€‹	2048 æ¸¸æˆè§„åˆ™çš„å…·ä½“å®ç°æœ‰ä¸€ä¸ªæ˜“é”™ä¹‹å¤„ï¼šåœ¨åŒè¡Œæˆ–è€…åŒåˆ—ä¸­è¿›è¡ŒæŸæ–¹å‘çš„æ»‘åŠ¨æ—¶ï¼Œè¿™è¡Œæˆ–è¿™åˆ—ä¸­çš„æ–¹å—ä»å‰å¾€åï¼ˆè®°æ»‘åŠ¨æ–¹å‘çš„ä¸€ä¾§ä¸ºå‰ï¼‰ä¾æ¬¡å‘å‰åˆå¹¶ï¼Œä¸”æ­¤æ¬¡æ“ä½œå·²ç»åˆå¹¶è¿‡çš„æ–¹å—ä¸èƒ½å†æ¬¡åˆå¹¶ã€‚ä¸æ¸¸æˆç›¸å…³çš„é¢˜ç›®ï¼ŒåŒ…æ‹¬2048çš„æ¸¸æˆè§„åˆ™æ¨¡æ‹Ÿï¼ˆhttp://cs101.openjudge.cn/practice/20052/ï¼‰ï¼Œå’Œä¸€ä¸ªéœ€è¦æ·±å…¥æŒ–æ˜2048è§„åˆ™æ€§è´¨çš„åŠ¨æ€è§„åˆ’é—®é¢˜ï¼ˆhttp://codeforces.com/problemset/problem/413/Dï¼‰ï¼Œå¸®åŠ©å­¦ç”Ÿæ·±å…¥ç†è§£æ¸¸æˆè§„åˆ™ã€‚åœ¨çº¿ä½“éªŒ 2048 æ¸¸æˆçš„ç½‘é¡µæœ‰ï¼š https://play2048.co/ ï¼Œhttps://2048game.com ã€‚



## 1. game_2048.py

è¯·å¸®æˆ‘å†™ä¸€ä¸ªpythonç¨‹åºï¼Œå°±æ˜¯åœ¨Mac terminalä¸­å¯ä»¥è¿è¡Œçš„ 2048 æ¸¸æˆï¼Œå¯ä»¥æ²¡æœ‰GUIã€‚

ç›®æ ‡è®¾ä¸º 2048ï¼Œä½†åœ¨è¾¾åˆ° 2048 åä¸ä¼šè‡ªåŠ¨ç»“æŸï¼Œä½ å¯ä»¥ç»§ç»­æ¸¸æˆäº‰å–æ›´é«˜çš„æ•°å­—ï¼š



<img src="https://raw.githubusercontent.com/GMyhf/img/main/img/image-20250219221003001.png" alt="image-20250219221003001" style="zoom:50%;" />



```python
#!/usr/bin/env python3
import random
import os
import sys

BOARD_SIZE = 4
TARGET = 2048

def init_board():
    board = [[0] * BOARD_SIZE for _ in range(BOARD_SIZE)]
    add_random_tile(board)
    add_random_tile(board)
    return board

def add_random_tile(board):
    empty = [(i, j) for i in range(BOARD_SIZE) for j in range(BOARD_SIZE) if board[i][j] == 0]
    if not empty:
        return
    i, j = random.choice(empty)
    board[i][j] = 4 if random.random() < 0.1 else 2

def print_board(board):
    os.system('clear')  # æ¸…å±
    print("-" * (BOARD_SIZE * 7 + 1))
    for row in board:
        print("|", end="")
        for num in row:
            if num == 0:
                print("      |", end="")
            else:
                print(f"{num:^6}|", end="")
        print()
        print("-" * (BOARD_SIZE * 7 + 1))

def slide_and_merge(line):
    new_line = [num for num in line if num != 0]
    merged_line = []
    skip = False
    for i in range(len(new_line)):
        if skip:
            skip = False
            continue
        if i + 1 < len(new_line) and new_line[i] == new_line[i + 1]:
            merged_line.append(new_line[i] * 2)
            skip = True
        else:
            merged_line.append(new_line[i])
    merged_line += [0] * (BOARD_SIZE - len(merged_line))
    return merged_line

def move_left(board):
    return [slide_and_merge(row) for row in board]

def reverse(board):
    return [list(reversed(row)) for row in board]

def transpose(board):
    return [list(row) for row in zip(*board)]

def move_right(board):
    return reverse(move_left(reverse(board)))

def move_up(board):
    transposed = transpose(board)
    moved = move_left(transposed)
    return transpose(moved)

def move_down(board):
    transposed = transpose(board)
    moved = move_right(transposed)
    return transpose(moved)

def boards_equal(b1, b2):
    for i in range(BOARD_SIZE):
        for j in range(BOARD_SIZE):
            if b1[i][j] != b2[i][j]:
                return False
    return True

def can_move(board):
    for row in board:
        if 0 in row:
            return True
    for i in range(BOARD_SIZE):
        for j in range(BOARD_SIZE):
            if j + 1 < BOARD_SIZE and board[i][j] == board[i][j + 1]:
                return True
            if i + 1 < BOARD_SIZE and board[i][j] == board[i + 1][j]:
                return True
    return False

def reached_target(board):
    for row in board:
        if any(num >= TARGET for num in row):
            return True
    return False

def main():
    board = init_board()
    has_printed_win = False  # é¿å…é‡å¤æ‰“å°è·èƒœæ¶ˆæ¯
    print_board(board)
    while True:
        move = input("è¯·è¾“å…¥ç§»åŠ¨æ–¹å‘ (w/a/s/d)ï¼Œæˆ– q é€€å‡ºï¼š").lower().strip()
        if move not in ['w', 'a', 's', 'd', 'q']:
            continue
        if move == 'q':
            print("é€€å‡ºæ¸¸æˆã€‚")
            sys.exit(0)

        if move == 'w':
            new_board = move_up(board)
        elif move == 'a':
            new_board = move_left(board)
        elif move == 's':
            new_board = move_down(board)
        elif move == 'd':
            new_board = move_right(board)

        if not boards_equal(board, new_board):
            board = new_board
            add_random_tile(board)
        else:
            print("æ— æ•ˆç§»åŠ¨ï¼")
        print_board(board)

        if reached_target(board) and not has_printed_win:
            print("æ­å–œä½ è¾¾åˆ°äº† 2048ï¼å½“ç„¶ï¼Œå¦‚æœèƒ½åˆæˆæ›´å¤§çš„æ•°å­—å°±æ›´å¥½ï¼")
            has_printed_win = True

        if not can_move(board):
            print("æ¸¸æˆç»“æŸï¼Œæ— æ³•ç§»åŠ¨ï¼")
            break

if __name__ == "__main__":
    main()
```

**ä½¿ç”¨è¯´æ˜**

1. å°†ä»£ç ä¿å­˜ä¸ºæ–‡ä»¶ï¼ˆä¾‹å¦‚ `game_2048.py`ï¼‰ã€‚
2. åœ¨ç»ˆç«¯ä¸­æ‰§è¡Œ `chmod +x game_2048.py` ç»™äºˆæ‰§è¡Œæƒé™ã€‚
3. è¿è¡Œ `./game_2048.py` å¯åŠ¨æ¸¸æˆã€‚

æ¸¸æˆä¸­è¾“å…¥ `w/a/s/d` åˆ†åˆ«æ§åˆ¶ä¸Šã€å·¦ã€ä¸‹ã€å³ç§»åŠ¨ï¼Œè¾“å…¥ `q` é€€å‡ºã€‚è¾¾åˆ° 2048 åä¼šæ˜¾ç¤ºæç¤ºï¼Œä½†ä½ ä»å¯ç»§ç»­æ¸¸æˆï¼ŒæŒ‘æˆ˜æ›´é«˜çš„åˆ†æ•°ã€‚



## 2. auto_2048.py

å¸®æˆ‘åšä¸€ä¸ªå‡çº§ç‰ˆæœ¬ï¼Œå°±æ˜¯è‡ªåŠ¨æ¼”ç¤ºä¸Šä¸‹å·¦å³ç§»åŠ¨çš„2048æ¸¸æˆ



ä¸‹é¢æ˜¯ä¸€ä»½è‡ªåŠ¨æ¼”ç¤ºç‰ˆ 2048 æ¸¸æˆçš„ Python ä»£ç ï¼Œè¿è¡Œæ—¶ä¼šè‡ªåŠ¨éšæœºé€‰æ‹©ä¸Šã€ä¸‹ã€å·¦ã€å³ç§»åŠ¨ï¼Œå¹¶åœ¨ç»ˆç«¯ä¸­å±•ç¤ºç§»åŠ¨è¿‡ç¨‹ã€‚ä½ å¯ä»¥ç›´æ¥åœ¨ Mac Terminal ä¸­è¿è¡Œè¯¥è„šæœ¬ï¼š

```python
#!/usr/bin/env python3
import random
import os
import sys
import time

BOARD_SIZE = 4
TARGET = 2048

def init_board():
    board = [[0] * BOARD_SIZE for _ in range(BOARD_SIZE)]
    add_random_tile(board)
    add_random_tile(board)
    return board

def add_random_tile(board):
    empty = [(i, j) for i in range(BOARD_SIZE) for j in range(BOARD_SIZE) if board[i][j] == 0]
    if not empty:
        return
    i, j = random.choice(empty)
    # ä»¥ 10% çš„æ¦‚ç‡ç”Ÿæˆ 4ï¼Œå…¶ä½™ç”Ÿæˆ 2
    board[i][j] = 4 if random.random() < 0.1 else 2

def print_board(board):
    os.system('clear')  # æ¸…å±
    print("-" * (BOARD_SIZE * 7 + 1))
    for row in board:
        print("|", end="")
        for num in row:
            if num == 0:
                print("      |", end="")
            else:
                print(f"{num:^6}|", end="")
        print()
        print("-" * (BOARD_SIZE * 7 + 1))

def slide_and_merge(line):
    # å»é™¤æ‰€æœ‰é›¶å€¼
    new_line = [num for num in line if num != 0]
    merged_line = []
    skip = False
    for i in range(len(new_line)):
        if skip:
            skip = False
            continue
        # è‹¥ç›¸é‚»æ•°å­—ç›¸ç­‰ï¼Œåˆ™åˆå¹¶
        if i + 1 < len(new_line) and new_line[i] == new_line[i + 1]:
            merged_line.append(new_line[i] * 2)
            skip = True
        else:
            merged_line.append(new_line[i])
    # è¡¥0ä½¿é•¿åº¦å›ºå®š
    merged_line += [0] * (BOARD_SIZE - len(merged_line))
    return merged_line

def move_left(board):
    new_board = []
    for row in board:
        new_board.append(slide_and_merge(row))
    return new_board

def reverse(board):
    return [list(reversed(row)) for row in board]

def transpose(board):
    return [list(row) for row in zip(*board)]

def move_right(board):
    return reverse(move_left(reverse(board)))

def move_up(board):
    transposed = transpose(board)
    moved = move_left(transposed)
    return transpose(moved)

def move_down(board):
    transposed = transpose(board)
    moved = move_right(transposed)
    return transpose(moved)

def boards_equal(b1, b2):
    for i in range(BOARD_SIZE):
        for j in range(BOARD_SIZE):
            if b1[i][j] != b2[i][j]:
                return False
    return True

def can_move(board):
    # è‹¥æœ‰ç©ºæ ¼åˆ™è‚¯å®šèƒ½ç§»åŠ¨
    for row in board:
        if 0 in row:
            return True
    # æ£€æŸ¥æ°´å¹³å’Œå‚ç›´æ˜¯å¦æœ‰å¯åˆå¹¶çš„æ•°å­—
    for i in range(BOARD_SIZE):
        for j in range(BOARD_SIZE):
            if j + 1 < BOARD_SIZE and board[i][j] == board[i][j + 1]:
                return True
            if i + 1 < BOARD_SIZE and board[i][j] == board[i + 1][j]:
                return True
    return False

def reached_target(board):
    for row in board:
        if any(num >= TARGET for num in row):
            return True
    return False

def main():
    board = init_board()
    has_printed_win = False  # é¿å…é‡å¤æ‰“å°è·èƒœæ¶ˆæ¯
    print_board(board)
    while True:
        if not can_move(board):
            print("æ¸¸æˆç»“æŸï¼Œæ— æ³•ç§»åŠ¨ï¼")
            break

        # è‡ªåŠ¨éšæœºé€‰æ‹©ä¸€ä¸ªæ–¹å‘
        move = random.choice(['w', 'a', 's', 'd'])
        print(f"è‡ªåŠ¨ç§»åŠ¨ï¼š{move}")
        if move == 'w':
            new_board = move_up(board)
        elif move == 'a':
            new_board = move_left(board)
        elif move == 's':
            new_board = move_down(board)
        elif move == 'd':
            new_board = move_right(board)

        if not boards_equal(board, new_board):
            board = new_board
            add_random_tile(board)
        else:
            print("æ— æ•ˆç§»åŠ¨ï¼Œå°è¯•å…¶ä»–æ–¹å‘ã€‚")

        print_board(board)
        if reached_target(board) and not has_printed_win:
            print("å·²è¾¾åˆ° 2048ï¼ç»§ç»­è‡ªåŠ¨ç§»åŠ¨ä»¥è·å¾—æ›´é«˜åˆ†æ•°ã€‚")
            has_printed_win = True

        time.sleep(0.01)  # å»¶æ—¶0.5ç§’ï¼Œä¾¿äºè§‚å¯Ÿæ¼”ç¤ºæ•ˆæœ

if __name__ == "__main__":
    main()
```

---

**ä½¿ç”¨è¯´æ˜**

1. å°†ä¸Šè¿°ä»£ç ä¿å­˜ä¸ºæ–‡ä»¶ï¼ˆä¾‹å¦‚ `auto_2048.py`ï¼‰ã€‚
2. åœ¨ç»ˆç«¯ä¸­è¿è¡Œå‘½ä»¤ `chmod +x auto_2048.py` èµ‹äºˆæ‰§è¡Œæƒé™ã€‚
3. è¿è¡Œ `./auto_2048.py` å¯åŠ¨è‡ªåŠ¨æ¼”ç¤ºã€‚

ç¨‹åºå°†è‡ªåŠ¨éšæœºé€‰æ‹©ä¸Šã€ä¸‹ã€å·¦ã€å³æ–¹å‘è¿›è¡Œç§»åŠ¨ï¼Œå¹¶ä»¥ 0.5 ç§’çš„é—´éš”æ›´æ–°æ˜¾ç¤ºã€‚ä½ å¯ä»¥é€šè¿‡ä¿®æ”¹ `time.sleep` çš„å»¶æ—¶å‚æ•°æ¥è°ƒæ•´æ¼”ç¤ºé€Ÿåº¦ã€‚





## 3. auto_2048_intelligent.py

èƒ½æ™ºèƒ½äº›å—ï¼Ÿåˆšè¿è¡Œauto_2048ï¼Œæ‰ç´¯ç§¯åˆ°128ï¼Œå°±æ¸¸æˆç»“æŸæ— æ³•ç§»åŠ¨äº†ã€‚



ä¸‹é¢æ˜¯ä¸€ä»½å‡çº§ç‰ˆè‡ªåŠ¨æ¼”ç¤º 2048 æ¸¸æˆä»£ç ï¼ŒåŠ å…¥äº†ç®€å•çš„å¯å‘å¼ç­–ç•¥ã€‚ç¨‹åºä¼šå¯¹å››ä¸ªæ–¹å‘çš„ç§»åŠ¨è¿›è¡Œæ¨¡æ‹Ÿï¼Œ<mark>é€‰æ‹©èƒ½ä½¿ç©ºæ ¼æœ€å¤šçš„é‚£ä¸€æ­¥ï¼Œä»è€Œå°½é‡å»¶é•¿æ¸¸æˆæ—¶é—´ï¼Œé¿å…æ—©æœŸå¡æ­»</mark>ã€‚ä½ å¯ä»¥ç›´æ¥åœ¨ Mac Terminal ä¸‹è¿è¡Œè¯¥è„šæœ¬ï¼š

```python
#!/usr/bin/env python3
import random
import os
import sys
import time

BOARD_SIZE = 4
TARGET = 2048

def init_board():
    board = [[0] * BOARD_SIZE for _ in range(BOARD_SIZE)]
    add_random_tile(board)
    add_random_tile(board)
    return board

def add_random_tile(board):
    empty = [(i, j) for i in range(BOARD_SIZE) for j in range(BOARD_SIZE) if board[i][j] == 0]
    if not empty:
        return
    i, j = random.choice(empty)
    board[i][j] = 4 if random.random() < 0.1 else 2

def print_board(board):
    os.system('clear')  # æ¸…å±
    print("-" * (BOARD_SIZE * 7 + 1))
    for row in board:
        print("|", end="")
        for num in row:
            if num == 0:
                print("      |", end="")
            else:
                print(f"{num:^6}|", end="")
        print()
        print("-" * (BOARD_SIZE * 7 + 1))

def slide_and_merge(line):
    new_line = [num for num in line if num != 0]
    merged_line = []
    skip = False
    for i in range(len(new_line)):
        if skip:
            skip = False
            continue
        if i + 1 < len(new_line) and new_line[i] == new_line[i + 1]:
            merged_line.append(new_line[i] * 2)
            skip = True
        else:
            merged_line.append(new_line[i])
    merged_line += [0] * (BOARD_SIZE - len(merged_line))
    return merged_line

def move_left(board):
    return [slide_and_merge(row) for row in board]

def reverse(board):
    return [list(reversed(row)) for row in board]

def transpose(board):
    return [list(row) for row in zip(*board)]

def move_right(board):
    return reverse(move_left(reverse(board)))

def move_up(board):
    transposed = transpose(board)
    moved = move_left(transposed)
    return transpose(moved)

def move_down(board):
    transposed = transpose(board)
    moved = move_right(transposed)
    return transpose(moved)

def boards_equal(b1, b2):
    for i in range(BOARD_SIZE):
        for j in range(BOARD_SIZE):
            if b1[i][j] != b2[i][j]:
                return False
    return True

def can_move(board):
    for row in board:
        if 0 in row:
            return True
    for i in range(BOARD_SIZE):
        for j in range(BOARD_SIZE):
            if j + 1 < BOARD_SIZE and board[i][j] == board[i][j + 1]:
                return True
            if i + 1 < BOARD_SIZE and board[i][j] == board[i + 1][j]:
                return True
    return False

def reached_target(board):
    for row in board:
        if any(num >= TARGET for num in row):
            return True
    return False

def count_empty(board):
    return sum(row.count(0) for row in board)

def choose_best_move(board):
    moves = {
        'w': move_up,
        'a': move_left,
        's': move_down,
        'd': move_right
    }
    best_move = None
    best_score = -1
    best_new_board = None
    for move, func in moves.items():
        new_board = func(board)
        if boards_equal(board, new_board):
            continue
        score = count_empty(new_board)
        if score > best_score:
            best_score = score
            best_move = move
            best_new_board = new_board
    return best_move, best_new_board

def main():
    board = init_board()
    has_printed_win = False
    print_board(board)
    while True:
        if not can_move(board):
            print("æ¸¸æˆç»“æŸï¼Œæ— æ³•ç§»åŠ¨ï¼")
            break

        move, new_board = choose_best_move(board)
        if move is None:
            print("æ²¡æœ‰æœ‰æ•ˆç§»åŠ¨ï¼Œæ¸¸æˆç»“æŸï¼")
            break

        print(f"è‡ªåŠ¨ç§»åŠ¨ï¼š{move}")
        board = new_board
        add_random_tile(board)
        print_board(board)

        if reached_target(board) and not has_printed_win:
            print("å·²è¾¾åˆ° 2048ï¼ç»§ç»­è‡ªåŠ¨ç§»åŠ¨ä»¥è·å¾—æ›´é«˜åˆ†æ•°ã€‚")
            has_printed_win = True

        time.sleep(0.01)

if __name__ == "__main__":
    main()
```

---

ä½¿ç”¨è¯´æ˜

1. å°†ä¸Šè¿°ä»£ç ä¿å­˜ä¸ºæ–‡ä»¶ï¼ˆä¾‹å¦‚ `auto_2048_intelligent.py`ï¼‰ã€‚
2. åœ¨ç»ˆç«¯ä¸­æ‰§è¡Œ `chmod +x auto_2048_intelligent.py` èµ‹äºˆæ‰§è¡Œæƒé™ã€‚
3. è¿è¡Œ `./auto_2048_intelligent.py` å¯åŠ¨è‡ªåŠ¨æ¼”ç¤ºã€‚

ç¨‹åºä¼šè‡ªåŠ¨é€‰æ‹©å››ä¸ªæ–¹å‘ä¸­ä½¿ç©ºæ ¼æœ€å¤šçš„ç§»åŠ¨æ–¹å‘ï¼Œå°½é‡ä¿æŒæ£‹ç›˜å®½æ¾ï¼Œå¸®åŠ©ä½ ç´¯ç§¯åˆ°æ›´é«˜çš„åˆ†æ•°ã€‚ä½ ä¹Ÿå¯ä»¥è°ƒæ•´ `time.sleep` å»¶æ—¶å‚æ•°æ¥è§‚å¯Ÿç§»åŠ¨è¿‡ç¨‹ã€‚



## 4. auto_2048_ai.py

è¿˜æ˜¯ä¸å¤Ÿæ™ºèƒ½ï¼Œåˆ°128å°±ç»“æŸäº†



ä¸‹é¢æ˜¯ä¸€ä»½å‡çº§ç‰ˆè‡ªåŠ¨æ¼”ç¤º 2048 æ¸¸æˆä»£ç ï¼Œ<mark>é‡‡ç”¨äº†ç®€å•çš„â€œ1 å±‚æœŸæœ›æœç´¢ï¼ˆexpectimaxï¼‰â€ç­–ç•¥å’Œå¯å‘å¼è¯„ä¼°å‡½æ•°</mark>ï¼Œä»è€Œå°½å¯èƒ½é€‰æ‹©å¯¹å±€é¢æ›´æœ‰åˆ©çš„ç§»åŠ¨ã€‚è¯¥ä»£ç åœ¨æ¨¡æ‹Ÿæ¯ä¸ªå¯èƒ½ç§»åŠ¨åï¼Œå¯¹éšæœºæ–°å¢å—è¿›è¡Œå¹³å‡è¯„ä¼°ï¼Œç„¶åé€‰æ‹©è¯„åˆ†æœ€é«˜çš„ç§»åŠ¨æ–¹å‘ï¼Œä»è€Œå»¶é•¿æ¸¸æˆæ—¶é—´ï¼Œäº‰å–æ›´é«˜åˆ†æ•°ï¼š

```python
#!/usr/bin/env python3
import random
import os
import sys
import time
import copy

BOARD_SIZE = 4
TARGET = 2048

def init_board():
    board = [[0] * BOARD_SIZE for _ in range(BOARD_SIZE)]
    add_random_tile(board)
    add_random_tile(board)
    return board

def add_random_tile(board):
    empty = [(i, j) for i in range(BOARD_SIZE) for j in range(BOARD_SIZE) if board[i][j] == 0]
    if not empty:
        return
    i, j = random.choice(empty)
    board[i][j] = 4 if random.random() < 0.1 else 2

def print_board(board):
    os.system('clear')  # Mac/Linux ä¸‹æ¸…å±
    print("-" * (BOARD_SIZE * 7 + 1))
    for row in board:
        print("|", end="")
        for num in row:
            if num == 0:
                print("      |", end="")
            else:
                print(f"{num:^6}|", end="")
        print()
        print("-" * (BOARD_SIZE * 7 + 1))

def slide_and_merge(line):
    # å»é™¤0å€¼
    new_line = [num for num in line if num != 0]
    merged_line = []
    skip = False
    for i in range(len(new_line)):
        if skip:
            skip = False
            continue
        if i + 1 < len(new_line) and new_line[i] == new_line[i+1]:
            merged_line.append(new_line[i] * 2)
            skip = True
        else:
            merged_line.append(new_line[i])
    merged_line += [0] * (BOARD_SIZE - len(merged_line))
    return merged_line

def move_left(board):
    return [slide_and_merge(row) for row in board]

def reverse(board):
    return [list(reversed(row)) for row in board]

def transpose(board):
    return [list(row) for row in zip(*board)]

def move_right(board):
    return reverse(move_left(reverse(board)))

def move_up(board):
    transposed = transpose(board)
    moved = move_left(transposed)
    return transpose(moved)

def move_down(board):
    transposed = transpose(board)
    moved = move_right(transposed)
    return transpose(moved)

def boards_equal(b1, b2):
    for i in range(BOARD_SIZE):
        for j in range(BOARD_SIZE):
            if b1[i][j] != b2[i][j]:
                return False
    return True

def can_move(board):
    for row in board:
        if 0 in row:
            return True
    for i in range(BOARD_SIZE):
        for j in range(BOARD_SIZE):
            if j+1 < BOARD_SIZE and board[i][j] == board[i][j+1]:
                return True
            if i+1 < BOARD_SIZE and board[i][j] == board[i+1][j]:
                return True
    return False

def reached_target(board):
    for row in board:
        if any(num >= TARGET for num in row):
            return True
    return False

def count_empty(board):
    return sum(row.count(0) for row in board)

def evaluate_board(board):
    """
    ä¸€ä¸ªç®€å•çš„è¯„ä¼°å‡½æ•°ï¼Œç»¼åˆè€ƒè™‘ï¼š
    1. ç©ºæ ¼æ•°ï¼šç©ºæ ¼è¶Šå¤šè¶Šå¥½ï¼ˆä¹˜ä»¥è¾ƒå¤§æƒé‡ï¼‰
    2. æœ€å¤§æ•°å­—æ˜¯å¦åœ¨è§’è½ï¼šåœ¨è§’è½å¥–åŠ±
    3. è¡Œåˆ—å•è°ƒæ€§ï¼šå¦‚æœæ•´è¡Œæˆ–æ•´åˆ—æ˜¯å•è°ƒçš„ï¼Œç»™äºˆä¸€å®šå¥–åŠ±
    """
    score = count_empty(board) * 100

    max_tile = max(max(row) for row in board)
    # å¦‚æœæœ€å¤§æ•°å­—åœ¨è§’è½ï¼Œåˆ™å¥–åŠ±
    corners = [board[0][0], board[0][BOARD_SIZE-1], board[BOARD_SIZE-1][0], board[BOARD_SIZE-1][BOARD_SIZE-1]]
    if max_tile in corners:
        score += max_tile * 10

    # è¡Œå•è°ƒæ€§å¥–åŠ±
    for row in board:
        if all(row[i] >= row[i+1] for i in range(len(row)-1)) or all(row[i] <= row[i+1] for i in range(len(row)-1)):
            score += sum(row) * 0.1
    # åˆ—å•è°ƒæ€§å¥–åŠ±
    for col in zip(*board):
        if all(col[i] >= col[i+1] for i in range(len(col)-1)) or all(col[i] <= col[i+1] for i in range(len(col)-1)):
            score += sum(col) * 0.1

    return score

def expectimax_value(board):
    """
    1å±‚æœŸæœ›æœç´¢ï¼š
    å¯¹å½“å‰å±€é¢ï¼Œæ¨¡æ‹Ÿåœ¨æ¯ä¸ªç©ºæ ¼ä¸Šéšæœºç”Ÿæˆ2ï¼ˆæ¦‚ç‡0.9ï¼‰æˆ–4ï¼ˆæ¦‚ç‡0.1ï¼‰ï¼Œ
    è¿”å›å¹³å‡è¯„ä¼°å¾—åˆ†ã€‚
    """
    empty = [(i, j) for i in range(BOARD_SIZE) for j in range(BOARD_SIZE) if board[i][j] == 0]
    if not empty:
        return evaluate_board(board)
    total = 0
    for (i, j) in empty:
        board2 = copy.deepcopy(board)
        board2[i][j] = 2
        score2 = evaluate_board(board2)
        board4 = copy.deepcopy(board)
        board4[i][j] = 4
        score4 = evaluate_board(board4)
        total += 0.9 * score2 + 0.1 * score4
    return total / len(empty)

def choose_best_move(board):
    moves = {
        'w': move_up,
        'a': move_left,
        's': move_down,
        'd': move_right
    }
    best_move = None
    best_score = -float('inf')
    best_new_board = None
    for move, func in moves.items():
        new_board = func(board)
        if boards_equal(board, new_board):
            continue
        # ä½¿ç”¨1å±‚æœŸæœ›æœç´¢çš„è¯„ä¼°
        score = expectimax_value(new_board)
        if score > best_score:
            best_score = score
            best_move = move
            best_new_board = new_board
    return best_move, best_new_board

def main():
    board = init_board()
    has_printed_win = False
    print_board(board)
    while True:
        if not can_move(board):
            print("æ¸¸æˆç»“æŸï¼Œæ— æ³•ç§»åŠ¨ï¼")
            break

        move, new_board = choose_best_move(board)
        if move is None:
            print("æ²¡æœ‰æœ‰æ•ˆç§»åŠ¨ï¼Œæ¸¸æˆç»“æŸï¼")
            break

        print(f"è‡ªåŠ¨ç§»åŠ¨ï¼š{move}")
        board = new_board
        add_random_tile(board)
        print_board(board)

        if reached_target(board) and not has_printed_win:
            print("å·²è¾¾åˆ° 2048ï¼ç»§ç»­è‡ªåŠ¨ç§»åŠ¨ä»¥è·å¾—æ›´é«˜åˆ†æ•°ã€‚")
            has_printed_win = True

        time.sleep(0.01)

if __name__ == "__main__":
    main()
```

---

**ä½¿ç”¨è¯´æ˜**

1. å°†ä¸Šè¿°ä»£ç ä¿å­˜ä¸ºæ–‡ä»¶ï¼ˆä¾‹å¦‚ `auto_2048_ai.py`ï¼‰ã€‚
2. åœ¨ç»ˆç«¯ä¸­æ‰§è¡Œ `chmod +x auto_2048_ai.py` èµ‹äºˆæ‰§è¡Œæƒé™ã€‚
3. è¿è¡Œ `./auto_2048_ai.py` å¯åŠ¨è‡ªåŠ¨æ¼”ç¤ºã€‚

æ­¤ç‰ˆæœ¬é‡‡ç”¨äº†ç®€å•çš„å¯å‘å¼è¯„ä¼°å’Œ1å±‚æœŸæœ›æœç´¢ï¼š  
â€¢ æ¯ä¸ªå¯èƒ½çš„ç§»åŠ¨åï¼Œç¨‹åºä¼šæ¨¡æ‹Ÿåœ¨æ‰€æœ‰ç©ºä½ä¸Šæ–°å¢æ•°å­—ï¼ˆ2 å’Œ 4ï¼‰åè®¡ç®—å¹³å‡è¯„ä¼°åˆ†æ•°ï¼›  
â€¢ è¯„ä¼°å‡½æ•°ç»¼åˆè€ƒè™‘äº†ç©ºæ ¼æ•°é‡ã€æœ€å¤§æ•°å­—æ˜¯å¦å¤„äºè§’è½ä»¥åŠè¡Œåˆ—çš„å•è°ƒæ€§ã€‚  

è¿™æ ·æœ‰åŠ©äºç¨‹åºé€‰æ‹©æ›´åŠ â€œæ™ºèƒ½â€çš„ç§»åŠ¨æ–¹å‘ï¼Œäº‰å–è·å¾—æ›´é«˜çš„åˆ†æ•°è€Œä¸æ˜¯æ—©æ—©å¡æ­»ã€‚  
è¯·æ ¹æ®éœ€è¦è°ƒæ•´æƒé‡å’Œå»¶æ—¶ï¼ˆtime.sleepï¼‰å‚æ•°ä»¥è·å¾—æœ€ä½³æ•ˆæœã€‚





## 5.auto_2048_expectimax.py

è¿˜æ˜¯ä¸å¤Ÿæ™ºèƒ½ï¼Œåˆ°256å°±ç»“æŸäº†



ä¸‹é¢è¿™ä»½ä»£ç <mark>ä½¿ç”¨äº†å¤šå±‚ï¼ˆæ·±åº¦ 3ï¼‰æœŸæœ›æœç´¢ï¼ˆexpectimaxï¼‰ï¼Œå¹¶åœ¨è¯„ä¼°å‡½æ•°ä¸­åŠ å…¥äº†è§’è½æƒé‡ã€ç©ºæ ¼å¥–åŠ±ä»¥åŠè¡Œåˆ—å•è°ƒæ€§å¥–åŠ±</mark>ï¼Œä»¥æœŸä½¿ AI åœ¨é€‰æ‹©ç§»åŠ¨æ—¶æ›´â€œèªæ˜â€ï¼Œå°½é‡é¿å…æ—©æœŸå¡æ­»ã€‚è¯·æ³¨æ„ï¼Œç”±äºæœç´¢æ·±åº¦å¢åŠ ï¼Œè¿è¡Œé€Ÿåº¦å¯èƒ½ä¼šå˜æ…¢ä¸€äº›ï¼Œä½†é€šå¸¸èƒ½åœ¨ 4Ã—4 æ£‹ç›˜ä¸Šæ¥å—ã€‚

```python
#!/usr/bin/env python3
import random
import os
import sys
import time
import copy

BOARD_SIZE = 4
TARGET = 2048
SEARCH_DEPTH = 3  # å¢åŠ æœç´¢æ·±åº¦

def init_board():
    board = [[0] * BOARD_SIZE for _ in range(BOARD_SIZE)]
    add_random_tile(board)
    add_random_tile(board)
    return board

def add_random_tile(board):
    empty = [(i, j) for i in range(BOARD_SIZE) for j in range(BOARD_SIZE) if board[i][j] == 0]
    if not empty:
        return
    i, j = random.choice(empty)
    board[i][j] = 4 if random.random() < 0.1 else 2

def print_board(board):
    os.system('clear')  # Mac/Linux ä¸‹æ¸…å±
    print("-" * (BOARD_SIZE * 7 + 1))
    for row in board:
        print("|", end="")
        for num in row:
            if num == 0:
                print("      |", end="")
            else:
                print(f"{num:^6}|", end="")
        print()
        print("-" * (BOARD_SIZE * 7 + 1))

def slide_and_merge(line):
    new_line = [num for num in line if num != 0]
    merged_line = []
    skip = False
    for i in range(len(new_line)):
        if skip:
            skip = False
            continue
        if i + 1 < len(new_line) and new_line[i] == new_line[i + 1]:
            merged_line.append(new_line[i] * 2)
            skip = True
        else:
            merged_line.append(new_line[i])
    merged_line += [0] * (BOARD_SIZE - len(merged_line))
    return merged_line

def move_left(board):
    return [slide_and_merge(row) for row in board]

def reverse(board):
    return [list(reversed(row)) for row in board]

def transpose(board):
    return [list(row) for row in zip(*board)]

def move_right(board):
    return reverse(move_left(reverse(board)))

def move_up(board):
    return transpose(move_left(transpose(board)))

def move_down(board):
    return transpose(move_right(transpose(board)))

def boards_equal(b1, b2):
    for i in range(BOARD_SIZE):
        for j in range(BOARD_SIZE):
            if b1[i][j] != b2[i][j]:
                return False
    return True

def can_move(board):
    for row in board:
        if 0 in row:
            return True
    for i in range(BOARD_SIZE):
        for j in range(BOARD_SIZE):
            if j + 1 < BOARD_SIZE and board[i][j] == board[i][j + 1]:
                return True
            if i + 1 < BOARD_SIZE and board[i][j] == board[i + 1][j]:
                return True
    return False

def reached_target(board):
    for row in board:
        if any(num >= TARGET for num in row):
            return True
    return False

def evaluate_board(board):
    score = 0
    # å¥–åŠ±ç©ºæ ¼
    empty = sum(row.count(0) for row in board)
    score += empty * 100

    # ä½¿ç”¨ä¸€ä¸ªé¢„è®¾çš„æƒé‡çŸ©é˜µï¼Œé¼“åŠ±æœ€å¤§å€¼ä½äºè§’è½ï¼ˆè¿™é‡Œé‡‡ç”¨è›‡å½¢å¸ƒå±€ï¼‰
    weights = [
        [65536, 32768, 16384, 8192],
        [512,   1024,  2048,  4096],
        [256,    512,  1024,  2048],
        [128,    256,   512,  1024]
    ]
    for i in range(BOARD_SIZE):
        for j in range(BOARD_SIZE):
            score += board[i][j] * weights[i][j]

    # å¥–åŠ±è¡Œå•è°ƒæ€§
    for row in board:
        if all(row[i] >= row[i+1] for i in range(len(row)-1)) or all(row[i] <= row[i+1] for i in range(len(row)-1)):
            score += sum(row)
    # å¥–åŠ±åˆ—å•è°ƒæ€§
    for col in zip(*board):
        if all(col[i] >= col[i+1] for i in range(len(col)-1)) or all(col[i] <= col[i+1] for i in range(len(col)-1)):
            score += sum(col)

    return score

def expectimax(board, depth, is_player):
    if depth == 0 or not can_move(board):
        return evaluate_board(board)
    if is_player:
        best = -float('inf')
        # ç©å®¶èŠ‚ç‚¹ï¼šå°è¯•æ‰€æœ‰å››ä¸ªæ–¹å‘
        for move_func in [move_up, move_down, move_left, move_right]:
            new_board = move_func(board)
            if boards_equal(board, new_board):
                continue
            value = expectimax(new_board, depth, False)
            best = max(best, value)
        return best if best != -float('inf') else evaluate_board(board)
    else:
        # æ¦‚ç‡èŠ‚ç‚¹ï¼šæ¨¡æ‹Ÿåœ¨æ‰€æœ‰ç©ºæ ¼ä¸Šéšæœºå‡ºç° 2 æˆ– 4
        empty = [(i, j) for i in range(BOARD_SIZE) for j in range(BOARD_SIZE) if board[i][j] == 0]
        if not empty:
            return evaluate_board(board)
        total = 0.0
        for (i, j) in empty:
            for tile, prob in [(2, 0.9), (4, 0.1)]:
                new_board = copy.deepcopy(board)
                new_board[i][j] = tile
                total += prob * expectimax(new_board, depth - 1, True)
        return total / len(empty)

def choose_best_move(board):
    moves = {
        'w': move_up,
        'a': move_left,
        's': move_down,
        'd': move_right
    }
    best_move = None
    best_score = -float('inf')
    best_new_board = None
    for move, func in moves.items():
        new_board = func(board)
        if boards_equal(board, new_board):
            continue
        # æ­¤å¤„ä½¿ç”¨å¤šå±‚æœŸæœ›æœç´¢ï¼Œåç»­èŠ‚ç‚¹ä¸ºæ¦‚ç‡èŠ‚ç‚¹
        score = expectimax(new_board, SEARCH_DEPTH, False)
        if score > best_score:
            best_score = score
            best_move = move
            best_new_board = new_board
    return best_move, best_new_board

def main():
    board = init_board()
    has_printed_win = False
    print_board(board)
    while True:
        if not can_move(board):
            print("æ¸¸æˆç»“æŸï¼Œæ— æ³•ç§»åŠ¨ï¼")
            break

        move, new_board = choose_best_move(board)
        if move is None:
            print("æ²¡æœ‰æœ‰æ•ˆç§»åŠ¨ï¼Œæ¸¸æˆç»“æŸï¼")
            break

        print(f"è‡ªåŠ¨ç§»åŠ¨ï¼š{move}")
        board = new_board
        add_random_tile(board)
        print_board(board)

        if reached_target(board) and not has_printed_win:
            print("å·²è¾¾åˆ° 2048ï¼ç»§ç»­è‡ªåŠ¨ç§»åŠ¨ä»¥è·å¾—æ›´é«˜åˆ†æ•°ã€‚")
            has_printed_win = True

        time.sleep(0.01)

if __name__ == "__main__":
    main()
```

---

**ä½¿ç”¨è¯´æ˜**

1. å°†ä¸Šè¿°ä»£ç ä¿å­˜ä¸ºæ–‡ä»¶ï¼ˆä¾‹å¦‚ `auto_2048_expectimax.py`ï¼‰ã€‚
2. åœ¨ç»ˆç«¯ä¸­è¿è¡Œå‘½ä»¤ `chmod +x auto_2048_expectimax.py` èµ‹äºˆæ‰§è¡Œæƒé™ã€‚
3. è¿è¡Œ `./auto_2048_expectimax.py` å¯åŠ¨è‡ªåŠ¨æ¼”ç¤ºã€‚

æ­¤ç‰ˆæœ¬åœ¨ç©å®¶å†³ç­–èŠ‚ç‚¹ä¸­é‡‡ç”¨äº† 3 å±‚æœŸæœ›æœç´¢ï¼Œåœ¨æ¦‚ç‡èŠ‚ç‚¹ä¸Šæ¨¡æ‹Ÿæ‰€æœ‰å¯èƒ½çš„éšæœºæ–°å¢å—ï¼Œå¹¶ç»“åˆæ”¹è¿›çš„è¯„ä¼°å‡½æ•°ï¼Œä»¥æœŸå»¶é•¿æ¸¸æˆæ—¶é—´ã€å°½é‡é¿å…æ—©æœŸé™·å…¥æ­»å±€ã€‚ä½ å¯ä»¥æ ¹æ®éœ€è¦è°ƒæ•´ SEARCH_DEPTHã€æƒé‡çŸ©é˜µæˆ–å»¶æ—¶å‚æ•°ï¼ˆtime.sleepï¼‰ä»¥è·å¾—æ›´ä½³æ•ˆæœã€‚







## 6.auto_2048_optimized.py

è¿è¡Œå¤ªæ…¢äº†ï¼Œèƒ½ä¼˜åŒ–å—ï¼Ÿå¹¶ä¸”èƒ½å–å¾—2048ç»“æœæˆ–è€…æ›´é«˜



ä¸‹é¢æ˜¯ç»è¿‡ä¼˜åŒ–åçš„ç‰ˆæœ¬ï¼Œä¸»è¦åšäº†ä»¥ä¸‹æ”¹è¿›ï¼š

<img src="https://raw.githubusercontent.com/GMyhf/img/main/img/image-20250219230024196.png" alt="image-20250219230024196" style="zoom:50%;" />



â€¢ ç”¨å±€éƒ¨å‡½æ•°æ›¿æ¢ copy.deepcopyï¼Œæ”¹ç”¨ [row[:] for row in board] è¿›è¡Œæµ…æ‹·è´  
â€¢ å¢åŠ äº†ç¼“å­˜ï¼ˆè½¬ç½®è¡¨ï¼‰æ¥ä¿å­˜ expectimax è®¡ç®—ç»“æœï¼Œé¿å…é‡å¤æœç´¢ï¼Œä»è€Œæå‡æœç´¢é€Ÿåº¦  
â€¢ ä¿æŒ SEARCH_DEPTH ä¸º 3ï¼ˆå¯æ ¹æ®æ€§èƒ½å’Œæ•ˆæœè°ƒæ•´ï¼‰

è¯¥ç‰ˆæœ¬<mark>åœ¨ 4Ã—4 æ£‹ç›˜ä¸Šè¿è¡Œé€Ÿåº¦æœ‰è¾ƒå¤§æå‡ï¼Œå¹¶èƒ½æ›´æ™ºèƒ½åœ°é€‰æ‹©ç§»åŠ¨</mark>ï¼Œä»è€Œæœ‰æœ›è¾¾åˆ° 2048 ç”šè‡³æ›´é«˜åˆ†æ•°ã€‚

```python
#!/usr/bin/env python3
import random
import os
import sys
import time

BOARD_SIZE = 4
TARGET = 2048
SEARCH_DEPTH = 3  # æœç´¢æ·±åº¦

# ç¼“å­˜ expectimax è®¡ç®—ç»“æœ
cache = {}

def board_to_key(board):
    return tuple(tuple(row) for row in board)

def init_board():
    board = [[0] * BOARD_SIZE for _ in range(BOARD_SIZE)]
    add_random_tile(board)
    add_random_tile(board)
    return board

def add_random_tile(board):
    empty = [(i, j) for i in range(BOARD_SIZE) for j in range(BOARD_SIZE) if board[i][j] == 0]
    if not empty:
        return
    i, j = random.choice(empty)
    board[i][j] = 4 if random.random() < 0.1 else 2

def print_board(board):
    os.system('clear')
    print("-" * (BOARD_SIZE * 7 + 1))
    for row in board:
        print("|", end="")
        for num in row:
            if num == 0:
                print("      |", end="")
            else:
                print(f"{num:^6}|", end="")
        print()
        print("-" * (BOARD_SIZE * 7 + 1))

def slide_and_merge(line):
    new_line = [num for num in line if num != 0]
    merged_line = []
    skip = False
    for i in range(len(new_line)):
        if skip:
            skip = False
            continue
        if i + 1 < len(new_line) and new_line[i] == new_line[i+1]:
            merged_line.append(new_line[i] * 2)
            skip = True
        else:
            merged_line.append(new_line[i])
    merged_line += [0] * (BOARD_SIZE - len(merged_line))
    return merged_line

def move_left(board):
    return [slide_and_merge(row) for row in board]

def reverse(board):
    return [list(reversed(row)) for row in board]

def transpose(board):
    return [list(row) for row in zip(*board)]

def move_right(board):
    return reverse(move_left(reverse(board)))

def move_up(board):
    return transpose(move_left(transpose(board)))

def move_down(board):
    return transpose(move_right(transpose(board)))

def boards_equal(b1, b2):
    for i in range(BOARD_SIZE):
        for j in range(BOARD_SIZE):
            if b1[i][j] != b2[i][j]:
                return False
    return True

def can_move(board):
    for row in board:
        if 0 in row:
            return True
    for i in range(BOARD_SIZE):
        for j in range(BOARD_SIZE):
            if j + 1 < BOARD_SIZE and board[i][j] == board[i][j+1]:
                return True
            if i + 1 < BOARD_SIZE and board[i][j] == board[i+1][j]:
                return True
    return False

def reached_target(board):
    for row in board:
        if any(num >= TARGET for num in row):
            return True
    return False

def count_empty(board):
    return sum(row.count(0) for row in board)

def evaluate_board(board):
    score = 0
    # å¥–åŠ±ç©ºæ ¼
    empty = count_empty(board)
    score += empty * 100

    # æƒé‡çŸ©é˜µï¼ˆè›‡å½¢å¸ƒå±€ï¼‰ï¼Œé¼“åŠ±æœ€å¤§æ•°å­—ä½äºè§’è½
    weights = [
        [65536, 32768, 16384, 8192],
        [512,   1024,  2048,  4096],
        [256,    512,  1024,  2048],
        [128,    256,   512,  1024]
    ]
    for i in range(BOARD_SIZE):
        for j in range(BOARD_SIZE):
            score += board[i][j] * weights[i][j]

    # å¥–åŠ±è¡Œå•è°ƒæ€§
    for row in board:
        if all(row[i] >= row[i+1] for i in range(len(row)-1)) or all(row[i] <= row[i+1] for i in range(len(row)-1)):
            score += sum(row)
    # å¥–åŠ±åˆ—å•è°ƒæ€§
    for col in zip(*board):
        if all(col[i] >= col[i+1] for i in range(len(col)-1)) or all(col[i] <= col[i+1] for i in range(len(col)-1)):
            score += sum(col)
    return score

def expectimax(board, depth, is_player):
    key = (board_to_key(board), depth, is_player)
    if key in cache:
        return cache[key]
    if depth == 0 or not can_move(board):
        val = evaluate_board(board)
        cache[key] = val
        return val
    if is_player:
        best = -float('inf')
        for move_func in [move_up, move_down, move_left, move_right]:
            new_board = move_func(board)
            if boards_equal(board, new_board):
                continue
            val = expectimax(new_board, depth, False)
            best = max(best, val)
        result = best if best != -float('inf') else evaluate_board(board)
    else:
        empty = [(i, j) for i in range(BOARD_SIZE) for j in range(BOARD_SIZE) if board[i][j] == 0]
        if not empty:
            result = evaluate_board(board)
        else:
            total = 0.0
            for (i, j) in empty:
                for tile, prob in [(2, 0.9), (4, 0.1)]:
                    board_copy = [row[:] for row in board]
                    board_copy[i][j] = tile
                    total += prob * expectimax(board_copy, depth - 1, True)
            result = total / len(empty)
    cache[key] = result
    return result

def choose_best_move(board):
    moves = {
        'w': move_up,
        'a': move_left,
        's': move_down,
        'd': move_right
    }
    best_move = None
    best_score = -float('inf')
    best_new_board = None
    for move, func in moves.items():
        new_board = func(board)
        if boards_equal(board, new_board):
            continue
        score = expectimax(new_board, SEARCH_DEPTH, False)
        if score > best_score:
            best_score = score
            best_move = move
            best_new_board = new_board
    return best_move, best_new_board

def main():
    board = init_board()
    has_printed_win = False
    print_board(board)
    while True:
        if not can_move(board):
            print("æ¸¸æˆç»“æŸï¼Œæ— æ³•ç§»åŠ¨ï¼")
            break

        move, new_board = choose_best_move(board)
        if move is None:
            print("æ²¡æœ‰æœ‰æ•ˆç§»åŠ¨ï¼Œæ¸¸æˆç»“æŸï¼")
            break

        print(f"è‡ªåŠ¨ç§»åŠ¨ï¼š{move}")
        board = new_board
        add_random_tile(board)
        print_board(board)

        if reached_target(board) and not has_printed_win:
            print("å·²è¾¾åˆ° 2048ï¼ç»§ç»­è‡ªåŠ¨ç§»åŠ¨ä»¥è·å¾—æ›´é«˜åˆ†æ•°ã€‚")
            has_printed_win = True

        time.sleep(0.01)

if __name__ == "__main__":
    main()
```

---

ä½¿ç”¨è¯´æ˜

1. å°†ä¸Šè¿°ä»£ç ä¿å­˜ä¸ºæ–‡ä»¶ï¼ˆä¾‹å¦‚ `auto_2048_optimized.py`ï¼‰ã€‚  
2. åœ¨ç»ˆç«¯ä¸­è¿è¡Œ `chmod +x auto_2048_optimized.py` èµ‹äºˆæ‰§è¡Œæƒé™ã€‚  
3. è¿è¡Œ `./auto_2048_optimized.py` å¯åŠ¨è‡ªåŠ¨æ¼”ç¤ºã€‚

é€šè¿‡ç¼“å­˜å’Œæ”¹è¿›çš„æ‹·è´æ–¹å¼ï¼Œæ­¤ç‰ˆæœ¬åœ¨ä¿è¯ä¸€å®šæœç´¢æ·±åº¦çš„å‰æä¸‹é€Ÿåº¦æœ‰æ˜æ˜¾æå‡ã€‚å¸Œæœ›è¿™ç‰ˆèƒ½å¤Ÿæ›´ç¨³å®šåœ°è¾¾åˆ° 2048 æˆ–æ›´é«˜åˆ†æ•°ï¼ŒåŒæ—¶è¿è¡Œé€Ÿåº¦æ›´å¿«ã€‚





## 7. auto_2048_optimized4.py

å¹¶ä¸èƒ½æ€»æ˜¯å¾—åˆ°å¤§äºç­‰äº2048ï¼Œè¿˜æœ‰ä¼˜åŒ–æ–¹æ³•å—?



âœ… **ä¿®æ­£ç‚¹è§£æï¼š**

1. LRUç¼“å­˜æœºåˆ¶ï¼š
   - ç”¨ `functools.lru_cache` æ›¿ä»£æ‰‹åŠ¨ç»´æŠ¤çš„å­—å…¸ç¼“å­˜ã€‚
   - è®¾å®šäº†æœ€å¤§ç¼“å­˜å¤§å° `MAX_CACHE_SIZE`ï¼Œæ§åˆ¶ç¼“å­˜ä¸ä¼šæ— é™å¢é•¿ï¼Œé¿å…å†…å­˜æ— é™è†¨èƒ€å¯¼è‡´çš„ Out of memory é—®é¢˜ã€‚
2. å“ˆå¸Œé”®å’Œååºåˆ—åŒ–ï¼š
   - `board_to_key()` å°†æ£‹ç›˜è½¬ä¸ºä¸å¯å˜çš„ `tuple` æ ¼å¼ç”¨äºå“ˆå¸Œã€‚
   - `key_to_board()` åˆ™ååºåˆ—åŒ–ï¼Œç”¨äºä»ç¼“å­˜æå–ç»“æœåæ¢å¤æ£‹ç›˜çŠ¶æ€ã€‚

> ğŸ’¡ **é¢å¤–ä¼˜åŒ–å»ºè®®ï¼š**
>
> 1. åŠ¨æ€è°ƒæ•´ç¼“å­˜å¤§å°ï¼š
>
>    å¯ä»¥åŸºäºæœºå™¨çš„å¯ç”¨å†…å­˜åŠ¨æ€è°ƒæ•´`MAX_CACHE_SIZE`ï¼š
>
>    ```python
>    import psutil
>
>    mem = psutil.virtual_memory()
>    MAX_CACHE_SIZE = min(100000, mem.available // (1024 * 1024 * 10))  # 10MB per cache entry
>    ```
>
> 2. ç›‘æ§ç¼“å­˜å‘½ä¸­ç‡ï¼š
>
>    å¦‚æœæƒ³è¦è°ƒè¯•ç¼“å­˜æ•ˆæœï¼Œå¯ä»¥åŠ å…¥ç¼“å­˜å‘½ä¸­ç‡ç›‘æ§ï¼š
>
>    ```python
>    print(f"Cache info: {expectimax_cached.cache_info()}")
>    ```
>    
>    
>    ```
>    Cache info: CacheInfo(hits=2732535, misses=5037289, maxsize=40960000, currsize=5037284)
>    Cache info: CacheInfo(hits=2732535, misses=5037290, maxsize=40960000, currsize=5037285)
>    Cache info: CacheInfo(hits=2732535, misses=5037291, maxsize=40960000, currsize=5037286)
>    Cache info: CacheInfo(hits=2732535, misses=5037292, maxsize=40960000, currsize=5037287)
>    Cache info: CacheInfo(hits=2732535, misses=5037293, maxsize=40960000, currsize=5037288)
>    Cache info: CacheInfo(hits=2732535, misses=5037294, maxsize=40960000, currsize=5037289)
>    Cache info: CacheInfo(hits=2732535, misses=5037295, maxsize=40960000, currsize=5037291)
>    Cache info: CacheInfo(hits=2732535, misses=5037296, maxsize=40960000, currsize=5037291)
>    Cache info: CacheInfo(hits=2732535, misses=5037297, maxsize=40960000, currsize=5037292)
>    Cache info: CacheInfo(hits=2732535, misses=5037298, maxsize=40960000, currsize=5037293)
>    Cache info: CacheInfo(hits=2732535, misses=5037299, maxsize=40960000, currsize=5037294)
>    Cache info: CacheInfo(hits=2732535, misses=5037300, maxsize=40960000, currsize=5037295)
>    Cache info: CacheInfo(hits=2732535, misses=5037301, maxsize=40960000, currsize=5037296)
>    Cache info: CacheInfo(hits=2732535, misses=5037302, maxsize=40960000, currsize=5037297)
>    Cache info: CacheInfo(hits=2732535, misses=5037303, maxsize=40960000, currsize=5037298)
>    Cache info: CacheInfo(hits=2732535, misses=5037304, maxsize=40960000, currsize=5037299)
>    ```
>    
>    



`auto_2048_optimized.py`ä»£ç å®ç°äº†**Expectimax** æœç´¢ï¼Œå¹¶ä½¿ç”¨äº† **å¯å‘å¼è¯„ä¼°å‡½æ•°** è¿›è¡Œå†³ç­–ã€‚ç„¶è€Œï¼Œ**2048 ä¸èƒ½ä¿è¯æ¯æ¬¡éƒ½æˆåŠŸè¾¾æˆ**ï¼Œä¸»è¦å—ä»¥ä¸‹å‡ ä¸ªå› ç´ å½±å“ï¼š

1. **æœç´¢æ·±åº¦ä¸å¤Ÿï¼ˆSEARCH_DEPTH = 3ï¼‰**
   - æœç´¢æ·±åº¦è¶Šæ·±ï¼Œå†³ç­–è¶Šå‡†ç¡®ï¼Œä½†è®¡ç®—é‡ä¹Ÿéšä¹‹å¢é•¿ã€‚
   - ç›®å‰ `SEARCH_DEPTH = 3`ï¼Œå¯èƒ½ä¸è¶³ä»¥æ‰¾åˆ°æœ€ä½³ç­–ç•¥ï¼Œå¯¼è‡´æ¸¸æˆä¸­æœŸæ— æ³•ç»´æŒå±€åŠ¿ã€‚
2. **å¯å‘å¼å‡½æ•°æ”¹è¿›ç©ºé—´**
   - ç°æœ‰ **æƒé‡çŸ©é˜µ** (snake pattern) è¿‡äºå›ºå®šï¼Œå¯èƒ½æ— æ³•é€‚åº”ä¸åŒå±€åŠ¿ã€‚
   - éœ€è¦é¢å¤–è€ƒè™‘â€œå¹³æ»‘åº¦ (smoothness)â€ å’Œâ€œç©ºæ ¼æ•° (emptiness)â€ï¼Œé˜²æ­¢æ—©æœŸå¤±æ§ã€‚
3. **æœªä½¿ç”¨ **Pruningï¼ˆå‰ªæï¼‰
   - ç›®å‰ä»£ç ä¼šå°è¯•æ‰€æœ‰å¯èƒ½æƒ…å†µï¼Œè€Œä¸€äº›æ˜¾ç„¶è¾ƒå·®çš„å†³ç­–åº”è¯¥æå‰å‰ªæï¼Œä»¥æé«˜æœç´¢æ•ˆç‡ï¼Œå…è®¸æ›´æ·±çš„æœç´¢æ·±åº¦ã€‚



**ä¼˜åŒ–æ–¹æ¡ˆ**

ä»¥ä¸‹æ”¹è¿›å¯ä»¥æ˜¾è‘—æé«˜èƒœç‡ï¼Œä½¿æ¨¡å‹æ›´ç¨³å®šåœ°è¾¾åˆ° 2048ï¼Œç”šè‡³ 4096ï¼š

**1ï¸âƒ£ æé«˜æœç´¢æ·±åº¦**

- å¢åŠ æœç´¢æ·±åº¦ `SEARCH_DEPTH = 5` æˆ– `SEARCH_DEPTH = 6`
- **åŠ¨æ€æœç´¢æ·±åº¦**ï¼ˆå‰æœŸè¾ƒæµ…ï¼ŒåæœŸè¾ƒæ·±ï¼‰

```
python


CopyEdit
def get_dynamic_depth(board):
    """æ ¹æ®å±€åŠ¿åŠ¨æ€è°ƒæ•´æœç´¢æ·±åº¦"""
    empty_cells = count_empty(board)
    if empty_cells >= 6:
        return 3
    elif empty_cells >= 3:
        return 4
    else:
        return 5  # ç»ˆå±€æ—¶åŠ æ·±æœç´¢æ·±åº¦
```

ä¿®æ”¹ `choose_best_move` è°ƒç”¨ï¼š

```
python


CopyEdit
score = expectimax(new_board, get_dynamic_depth(board), False)
```

------

**2ï¸âƒ£ æ”¹è¿›å¯å‘å¼å‡½æ•°**

**âœ… å¢åŠ  "å¹³æ»‘åº¦" (smoothness)**

- <mark>ä¿æŒç›¸é‚»æ•°å­—çš„å¤§å°å°½é‡æ¥è¿‘ï¼Œé¿å…å¤§æ•°è¢«å›°ä½</mark>
- è®¡ç®—ç›¸é‚»æ ¼å­çš„ **å·®å€¼æ€»å’Œ**ï¼Œè¶Šå°è¶Šå¥½

```
python


CopyEdit
def calculate_smoothness(board):
    smoothness = 0
    for i in range(BOARD_SIZE):
        for j in range(BOARD_SIZE - 1):
            smoothness -= abs(board[i][j] - board[i][j+1])  # è¡Œ
            smoothness -= abs(board[j][i] - board[j+1][i])  # åˆ—
    return smoothness
```

**âœ… å¢åŠ  "å•è°ƒæ€§" (monotonicity)**

- <mark>æ£€æŸ¥æ˜¯å¦ä»å·¦åˆ°å³é€’å‡ï¼Œä»ä¸Šåˆ°ä¸‹é€’å‡</mark>

```
python


CopyEdit
def calculate_monotonicity(board):
    mono_rows = sum(board[i][j] >= board[i][j+1] for i in range(BOARD_SIZE) for j in range(BOARD_SIZE - 1))
    mono_cols = sum(board[j][i] >= board[j+1][i] for i in range(BOARD_SIZE) for j in range(BOARD_SIZE - 1))
    return mono_rows + mono_cols
```

**æ”¹è¿› `evaluate_board`ï¼š**

```python
def evaluate_board(board):
    empty = count_empty(board)
    smoothness = calculate_smoothness(board)
    monotonicity = calculate_monotonicity(board)

    weights = [
        [65536, 32768, 16384, 8192],
        [512,   1024,  2048,  4096],
        [256,    512,  1024,  2048],
        [128,    256,   512,  1024]
    ]
    weight_score = sum(board[i][j] * weights[i][j] for i in range(BOARD_SIZE) for j in range(BOARD_SIZE))

    return weight_score + empty * 500 + smoothness * 5 + monotonicity * 100
```

------



å®Œæ•´ä»£ç  `auto_2048_optimized4.py`

```python
#!/usr/bin/env python3
import random
import os
import time
from functools import lru_cache

BOARD_SIZE = 4
TARGET = 2048

# è®¾ç½®æœ€å¤§ç¼“å­˜å¤§å°ï¼Œé˜²æ­¢æ— é™å ç”¨å†…å­˜
MAX_CACHE_SIZE = 10000*4096

def board_to_key(board):
    """å°†æ£‹ç›˜è½¬åŒ–ä¸ºä¸å¯å˜å“ˆå¸Œé”®"""
    return tuple(tuple(row) for row in board)

def key_to_board(key):
    """å°†å“ˆå¸Œé”®è½¬å›æ£‹ç›˜"""
    return [list(row) for row in key]

@lru_cache(maxsize=MAX_CACHE_SIZE)
def expectimax_cached(board_key, depth, is_player):
    board = key_to_board(board_key)
    #print(f"Cache info: {expectimax_cached.cache_info()}")
    return expectimax(board, depth, is_player)

def init_board():
    board = [[0] * BOARD_SIZE for _ in range(BOARD_SIZE)]
    add_random_tile(board)
    add_random_tile(board)
    return board

def add_random_tile(board):
    empty = [(i, j) for i in range(BOARD_SIZE) for j in range(BOARD_SIZE) if board[i][j] == 0]
    if not empty:
        return
    i, j = random.choice(empty)
    board[i][j] = 4 if random.random() < 0.1 else 2

def print_board(board):
    # ä½¿ç”¨ ANSI è½¬ä¹‰ç æ¸…å±ï¼Œé¿å…ä¾èµ–å¤–éƒ¨å‘½ä»¤
    print('\033[H\033[J', end='')
    print("-" * (BOARD_SIZE * 7 + 1))
    for row in board:
        print("|", end="")
        for num in row:
            if num == 0:
                print("      |", end="")
            else:
                print(f"{num:^6}|", end="")
        print()
        print("-" * (BOARD_SIZE * 7 + 1))

def slide_and_merge(line):
    new_line = [num for num in line if num != 0]
    merged_line = []
    skip = False
    for i in range(len(new_line)):
        if skip:
            skip = False
            continue
        if i + 1 < len(new_line) and new_line[i] == new_line[i+1]:
            merged_line.append(new_line[i] * 2)
            skip = True
        else:
            merged_line.append(new_line[i])
    merged_line += [0] * (BOARD_SIZE - len(merged_line))
    return merged_line

def move_left(board):
    return [slide_and_merge(row) for row in board]

def reverse(board):
    return [list(reversed(row)) for row in board]

def transpose(board):
    return [list(row) for row in zip(*board)]

def move_right(board):
    return reverse(move_left(reverse(board)))

def move_up(board):
    return transpose(move_left(transpose(board)))

def move_down(board):
    return transpose(move_right(transpose(board)))

def boards_equal(b1, b2):
    for i in range(BOARD_SIZE):
        for j in range(BOARD_SIZE):
            if b1[i][j] != b2[i][j]:
                return False
    return True

def can_move(board):
    for row in board:
        if 0 in row:
            return True
    for i in range(BOARD_SIZE):
        for j in range(BOARD_SIZE):
            if j + 1 < BOARD_SIZE and board[i][j] == board[i][j+1]:
                return True
            if i + 1 < BOARD_SIZE and board[i][j] == board[i+1][j]:
                return True
    return False

def reached_target(board):
    for row in board:
        if any(num >= TARGET for num in row):
            return True
    return False

def count_empty(board):
    return sum(row.count(0) for row in board)

def calculate_smoothness(board):
    """è®¡ç®—å¹³æ»‘åº¦ï¼šç›¸é‚»å•å…ƒæ ¼å·®å€¼çš„æ€»å’Œï¼ˆå·®å€¼è¶Šå°è¶Šå¥½ï¼‰"""
    smooth = 0
    for i in range(BOARD_SIZE):
        for j in range(BOARD_SIZE - 1):
            smooth -= abs(board[i][j] - board[i][j+1])
    for j in range(BOARD_SIZE):
        for i in range(BOARD_SIZE - 1):
            smooth -= abs(board[i][j] - board[i+1][j])
    return smooth

def calculate_monotonicity(board):
    """è®¡ç®—å•è°ƒæ€§ï¼šå¦‚æœè¡Œæˆ–åˆ—å•è°ƒæ€§å¥½åˆ™å¥–åŠ±"""
    mono_rows = 0
    mono_cols = 0
    for row in board:
        if all(row[i] >= row[i+1] for i in range(BOARD_SIZE - 1)) or all(row[i] <= row[i+1] for i in range(BOARD_SIZE - 1)):
            mono_rows += 1
    for col in zip(*board):
        if all(col[i] >= col[i+1] for i in range(BOARD_SIZE - 1)) or all(col[i] <= col[i+1] for i in range(BOARD_SIZE - 1)):
            mono_cols += 1
    return mono_rows + mono_cols

def evaluate_board(board):
    empty = count_empty(board)
    smoothness = calculate_smoothness(board)
    monotonicity = calculate_monotonicity(board)
    # åŸå§‹æƒé‡çŸ©é˜µï¼ˆè›‡å½¢å¸ƒå±€ï¼‰ï¼Œé¼“åŠ±å¤§æ•°é›†ä¸­åœ¨è§’è½
    weights = [
        [65536, 32768, 16384, 8192],
        [512,   1024,  2048,  4096],
        [256,    512,  1024,  2048],
        [128,    256,   512,  1024]
    ]
    weight_score = sum(board[i][j] * weights[i][j] for i in range(BOARD_SIZE) for j in range(BOARD_SIZE))
    # å¢åŠ ç©ºæ ¼ã€å¹³æ»‘åº¦å’Œå•è°ƒæ€§çš„å¥–åŠ±
    return weight_score + empty * 500 + smoothness * 5 + monotonicity * 100

def expectimax(board, depth, is_player):
    if depth == 0 or not can_move(board):
        return evaluate_board(board)
    if is_player:
        best = -float('inf')
        for move_func in [move_up, move_down, move_left, move_right]:
            new_board = move_func(board)
            if boards_equal(board, new_board):
                continue
            val = expectimax_cached(board_to_key(new_board), depth - 1, False)
            best = max(best, val)
        return best if best != -float('inf') else evaluate_board(board)
    else:
        empty = [(i, j) for i in range(BOARD_SIZE) for j in range(BOARD_SIZE) if board[i][j] == 0]
        if not empty:
            return evaluate_board(board)
        total = 0.0
        for (i, j) in empty:
            for tile, prob in [(2, 0.9), (4, 0.1)]:
                board_copy = [row[:] for row in board]
                board_copy[i][j] = tile
                total += prob * expectimax_cached(board_to_key(board_copy), depth - 1, True)
        return total / len(empty)

def get_dynamic_depth(board):
    """æ ¹æ®å½“å‰ç©ºæ ¼æ•°é‡åŠ¨æ€è°ƒæ•´æœç´¢æ·±åº¦ï¼šç©ºæ ¼è¶Šå°‘æœç´¢æ·±åº¦è¶Šæ·±"""
    empty_cells = count_empty(board)
    if empty_cells >= 6:
        return 4
    elif empty_cells >= 3:
        return 5
    else:
        return 6

def choose_best_move(board):
    moves = {
        'w': move_up,
        'a': move_left,
        's': move_down,
        'd': move_right
    }
    best_move = None
    best_score = -float('inf')
    best_new_board = None
    depth = get_dynamic_depth(board)
    for move, func in moves.items():
        new_board = func(board)
        if boards_equal(board, new_board):
            continue
        score = expectimax(new_board, depth, False)
        if score > best_score:
            best_score = score
            best_move = move
            best_new_board = new_board
    return best_move, best_new_board

def main():
    board = init_board()
    has_printed_win = False
    print_board(board)
    while True:
        if not can_move(board):
            print("æ¸¸æˆç»“æŸï¼Œæ— æ³•ç§»åŠ¨ï¼")
            break
        move, new_board = choose_best_move(board)
        if move is None:
            print("æ²¡æœ‰æœ‰æ•ˆç§»åŠ¨ï¼Œæ¸¸æˆç»“æŸï¼")
            break
        print(f"è‡ªåŠ¨ç§»åŠ¨ï¼š{move}")
        board = new_board
        add_random_tile(board)
        print_board(board)
        if reached_target(board) and not has_printed_win:
            print("å·²è¾¾åˆ° 2048ï¼ç»§ç»­è‡ªåŠ¨ç§»åŠ¨ä»¥è·å¾—æ›´é«˜åˆ†æ•°ã€‚")
            has_printed_win = True
        time.sleep(0.0001)

if __name__ == "__main__":
    main()


```

Q. `print('\033[H\033[J', end='')` æ˜¯ä»€ä¹ˆæ„æ€ï¼Ÿ

è¿™æ˜¯ä¸€ä¸ªåœ¨Pythonä¸­ä½¿ç”¨çš„ANSIè½¬ä¹‰åºåˆ—ï¼Œç”¨äºæ§åˆ¶ç»ˆç«¯ï¼ˆå‘½ä»¤è¡Œç•Œé¢ï¼‰ä¸­çš„å…‰æ ‡ä½ç½®å’Œæ¸…é™¤å±å¹•å†…å®¹

`\033` æ˜¯å…«è¿›åˆ¶è¡¨ç¤ºçš„ESC (Escape) å­—ç¬¦çš„ASCIIç ï¼Œç”¨äºè¡¨ç¤ºè½¬ä¹‰åºåˆ—çš„å¼€å§‹ã€‚
`[` æ˜¯å·¦æ–¹æ‹¬å·ï¼Œä¸ESCå­—ç¬¦ä¸€èµ·ç»„æˆè½¬ä¹‰åºåˆ—çš„å¼€å§‹ã€‚
`H` è¡¨ç¤ºå°†å…‰æ ‡ç§»åŠ¨åˆ°è¡Œé¦–ï¼ˆhome positionï¼‰ã€‚
`J` è¡¨ç¤ºæ¸…é™¤ä»å…‰æ ‡ä½ç½®åˆ°å±å¹•æœ«å°¾çš„å†…å®¹ã€‚

å› æ­¤ï¼Œ`\033[H\033[J` çš„æ„æ€æ˜¯ï¼šå°†å…‰æ ‡ç§»åŠ¨åˆ°ç»ˆç«¯çš„å·¦ä¸Šè§’ï¼ˆè¡Œé¦–ï¼‰ï¼Œç„¶åæ¸…é™¤ä»å…‰æ ‡æ‰€åœ¨ä½ç½®åˆ°å±å¹•æœ«å°¾çš„æ‰€æœ‰å†…å®¹ã€‚åœ¨Pythonå­—ç¬¦ä¸²ä¸­ï¼Œ`end=''` å‚æ•°è¡¨ç¤ºåœ¨æ‰“å°ç»“æŸåä¸è¦æ¢è¡Œã€‚

**ç»“è®º**

- 2048 æ¸¸æˆ**æœ¬è´¨ä¸Šæ˜¯æ¦‚ç‡é—®é¢˜**ï¼Œä½†é€šè¿‡ **æ›´å¥½çš„å¯å‘å¼è¯„åˆ† +  åŠ¨æ€æœç´¢æ·±åº¦**ï¼Œèƒœç‡å¯ä»¥å¤§å¹…æå‡ã€‚
- ç»è¿‡ä¼˜åŒ–ï¼Œé€šå¸¸èƒ½ç¨³å®šè¾¾åˆ° 2048 æˆ– 4096ã€‚





## 8. auto_2048_expectimax_ab.py

**Alpha-Betaå‰ªæå‰ªæçš„åŸºæœ¬åŸç†**

Alpha-Betaå‰ªææ˜¯ä¸€ç§ç”¨äºå‡å°‘æœç´¢ç©ºé—´çš„æŠ€æœ¯ï¼Œä¸»è¦åº”ç”¨äºMinimaxç®—æ³•åŠå…¶å˜ç§ï¼ˆå¦‚Expectimaxï¼‰ã€‚å…¶æ ¸å¿ƒæ€æƒ³æ˜¯é€šè¿‡ç»´æŠ¤ä¸¤ä¸ªå€¼ï¼š

- **Alphaï¼ˆÎ±ï¼‰**: å½“å‰è·¯å¾„ä¸ŠMaxèŠ‚ç‚¹çš„æœ€ä½³é€‰æ‹©ï¼ˆå³æœ€å°åŒ–å¯¹æ‰‹å¾—åˆ†çš„æœ€å¤§å€¼ï¼‰ã€‚
- **Betaï¼ˆÎ²ï¼‰**: å½“å‰è·¯å¾„ä¸ŠMinèŠ‚ç‚¹çš„æœ€ä½³é€‰æ‹©ï¼ˆå³æœ€å¤§åŒ–ç©å®¶å¾—åˆ†çš„æœ€å°å€¼ï¼‰ã€‚

å½“æŸä¸ªèŠ‚ç‚¹çš„å€¼ä¸å¯èƒ½å½±å“æœ€ç»ˆå†³ç­–æ—¶ï¼Œå¯ä»¥æå‰å‰ªå»è¯¥èŠ‚ç‚¹åŠå…¶å­æ ‘ï¼Œä»è€Œå‡å°‘è®¡ç®—é‡ã€‚

**è¯´æ˜ï¼š**

- **ä»…åœ¨ç©å®¶ï¼ˆmaxï¼‰èŠ‚ç‚¹ä½¿ç”¨ alphaâ€‘beta å‰ªæ**  
  åœ¨ chanceï¼ˆéç©å®¶ï¼‰èŠ‚ç‚¹ï¼Œç”±äºæœŸæœ›å€¼è®¡ç®—çš„æ€§è´¨ï¼Œä¸å†ä½¿ç”¨ beta æ›´æ–°å’Œå‰ªæã€‚è¿™æ ·å¯ä»¥é¿å…è¿‡æ—©å‰ªæå¯¼è‡´å†³ç­–å¤±è¯¯ã€‚

- å…¶å®ƒéƒ¨åˆ†ä¿æŒåŸæœ‰æ”¹è¿›ï¼ˆåŠ¨æ€æœç´¢æ·±åº¦ã€æ”¹è¿›è¯„ä¼°å‡½æ•°ã€LRU ç¼“å­˜ç­‰ï¼‰ã€‚

å®Œæ•´ä»£ç  `auto_2048_expectimax_ab.py`

```python
#!/usr/bin/env python3
import random
import os
import time
from functools import lru_cache

BOARD_SIZE = 4
TARGET = 2048
MAX_CACHE_SIZE = 10000

def board_to_key(board):
    """å°†æ£‹ç›˜è½¬åŒ–ä¸ºä¸å¯å˜çš„å“ˆå¸Œé”®"""
    return tuple(tuple(row) for row in board)

def key_to_board(key):
    """å°†å“ˆå¸Œé”®è½¬å›æ£‹ç›˜"""
    return [list(row) for row in key]

@lru_cache(maxsize=MAX_CACHE_SIZE)
def expectimax_ab(board_key, depth, is_player, alpha, beta):
    """
    ä½¿ç”¨ alpha-beta å‰ªæçš„ Expectimax æœç´¢ã€‚
    æ³¨æ„ï¼šä»…åœ¨ç©å®¶ï¼ˆmaxï¼‰èŠ‚ç‚¹ä½¿ç”¨å‰ªæï¼Œ
    åœ¨ chance èŠ‚ç‚¹ä¸åšå‰ªæï¼Œç›´æ¥è®¡ç®—æœŸæœ›å€¼ã€‚
    """
    board = key_to_board(board_key)
    if depth == 0 or not can_move(board):
        return evaluate_board(board)
    
    if is_player:
        best = -float('inf')
        a = alpha
        for move_func in [move_up, move_down, move_left, move_right]:
            new_board = move_func(board)
            if boards_equal(board, new_board):
                continue
            val = expectimax_ab(board_to_key(new_board), depth - 1, False, a, beta)
            best = max(best, val)
            a = max(a, best)
            if a >= beta:
                break  # å‰ªæï¼šå½“å‰åˆ†æ”¯å·²ç»è¶³å¤Ÿå¥½
        return best
    else:
        # åœ¨ chance èŠ‚ç‚¹ç›´æ¥è®¡ç®—æ‰€æœ‰å¯èƒ½æƒ…å†µçš„æœŸæœ›å€¼ï¼Œä¸è¿›è¡Œå‰ªæ
        empty = [(i, j) for i in range(BOARD_SIZE) for j in range(BOARD_SIZE) if board[i][j] == 0]
        if not empty:
            return evaluate_board(board)
        total = 0.0
        for (i, j) in empty:
            for tile, prob in [(2, 0.9), (4, 0.1)]:
                board_copy = [row[:] for row in board]
                board_copy[i][j] = tile
                val = expectimax_ab(board_to_key(board_copy), depth - 1, True, alpha, beta)
                total += prob * val
        return total / len(empty)

def init_board():
    board = [[0] * BOARD_SIZE for _ in range(BOARD_SIZE)]
    add_random_tile(board)
    add_random_tile(board)
    return board

def add_random_tile(board):
    empty = [(i, j) for i in range(BOARD_SIZE) for j in range(BOARD_SIZE) if board[i][j] == 0]
    if not empty:
        return
    i, j = random.choice(empty)
    board[i][j] = 4 if random.random() < 0.1 else 2

def print_board(board):
    # ä½¿ç”¨ ANSI è½¬ä¹‰ç æ¸…å±
    print('\033[H\033[J', end='')
    print("-" * (BOARD_SIZE * 7 + 1))
    for row in board:
        print("|", end="")
        for num in row:
            if num == 0:
                print("      |", end="")
            else:
                print(f"{num:^6}|", end="")
        print()
        print("-" * (BOARD_SIZE * 7 + 1))

def slide_and_merge(line):
    new_line = [num for num in line if num != 0]
    merged_line = []
    skip = False
    for i in range(len(new_line)):
        if skip:
            skip = False
            continue
        if i + 1 < len(new_line) and new_line[i] == new_line[i+1]:
            merged_line.append(new_line[i] * 2)
            skip = True
        else:
            merged_line.append(new_line[i])
    merged_line += [0] * (BOARD_SIZE - len(merged_line))
    return merged_line

def move_left(board):
    return [slide_and_merge(row) for row in board]

def reverse(board):
    return [list(reversed(row)) for row in board]

def transpose(board):
    return [list(row) for row in zip(*board)]

def move_right(board):
    return reverse(move_left(reverse(board)))

def move_up(board):
    return transpose(move_left(transpose(board)))

def move_down(board):
    return transpose(move_right(transpose(board)))

def boards_equal(b1, b2):
    for i in range(BOARD_SIZE):
        for j in range(BOARD_SIZE):
            if b1[i][j] != b2[i][j]:
                return False
    return True

def can_move(board):
    for row in board:
        if 0 in row:
            return True
    for i in range(BOARD_SIZE):
        for j in range(BOARD_SIZE):
            if j + 1 < BOARD_SIZE and board[i][j] == board[i][j+1]:
                return True
            if i + 1 < BOARD_SIZE and board[i][j] == board[i+1][j]:
                return True
    return False

def reached_target(board):
    for row in board:
        if any(num >= TARGET for num in row):
            return True
    return False

def count_empty(board):
    return sum(row.count(0) for row in board)

def calculate_smoothness(board):
    """è®¡ç®—å¹³æ»‘åº¦ï¼šç›¸é‚»å•å…ƒæ ¼å·®å€¼çš„æ€»å’Œï¼ˆå·®å€¼è¶Šå°è¶Šå¥½ï¼‰"""
    smooth = 0
    for i in range(BOARD_SIZE):
        for j in range(BOARD_SIZE - 1):
            smooth -= abs(board[i][j] - board[i][j+1])
    for j in range(BOARD_SIZE):
        for i in range(BOARD_SIZE - 1):
            smooth -= abs(board[i][j] - board[i+1][j])
    return smooth

def calculate_monotonicity(board):
    """è®¡ç®—å•è°ƒæ€§ï¼šå¦‚æœè¡Œæˆ–åˆ—å•è°ƒæ€§å¥½åˆ™å¥–åŠ±"""
    mono_rows = 0
    mono_cols = 0
    for row in board:
        if all(row[i] >= row[i+1] for i in range(BOARD_SIZE-1)) or all(row[i] <= row[i+1] for i in range(BOARD_SIZE-1)):
            mono_rows += 1
    for col in zip(*board):
        if all(col[i] >= col[i+1] for i in range(BOARD_SIZE-1)) or all(col[i] <= col[i+1] for i in range(BOARD_SIZE-1)):
            mono_cols += 1
    return mono_rows + mono_cols

def evaluate_board(board):
    empty = count_empty(board)
    smoothness = calculate_smoothness(board)
    monotonicity = calculate_monotonicity(board)
    # æƒé‡çŸ©é˜µï¼ˆè›‡å½¢å¸ƒå±€ï¼‰ï¼Œé¼“åŠ±å¤§æ•°é›†ä¸­åœ¨è§’è½
    weights = [
        [65536, 32768, 16384, 8192],
        [512,   1024,  2048,  4096],
        [256,    512,  1024,  2048],
        [128,    256,   512,  1024]
    ]
    weight_score = sum(board[i][j] * weights[i][j] for i in range(BOARD_SIZE) for j in range(BOARD_SIZE))
    return weight_score + empty * 500 + smoothness * 5 + monotonicity * 100

def get_dynamic_depth(board):
    """æ ¹æ®å½“å‰ç©ºæ ¼æ•°é‡åŠ¨æ€è°ƒæ•´æœç´¢æ·±åº¦ï¼šç©ºæ ¼è¶Šå°‘ï¼Œå±€åŠ¿è¶Šç´§å¼ ï¼Œæœç´¢æ·±åº¦åŠ æ·±"""
    empty_cells = count_empty(board)
    if empty_cells >= 6:
        return 4
    elif empty_cells >= 3:
        return 5
    else:
        return 6

def choose_best_move(board):
    moves = {
        'w': move_up,
        'a': move_left,
        's': move_down,
        'd': move_right
    }
    best_move = None
    best_score = -float('inf')
    best_new_board = None
    depth = get_dynamic_depth(board)
    for move, func in moves.items():
        new_board = func(board)
        if boards_equal(board, new_board):
            continue
        score = expectimax_ab(board_to_key(new_board), depth, False, -float('inf'), float('inf'))
        if score > best_score:
            best_score = score
            best_move = move
            best_new_board = new_board
    return best_move, best_new_board

def main():
    board = init_board()
    has_printed_win = False
    print_board(board)
    while True:
        if not can_move(board):
            print("æ¸¸æˆç»“æŸï¼Œæ— æ³•ç§»åŠ¨ï¼")
            break
        move, new_board = choose_best_move(board)
        if move is None:
            print("æ²¡æœ‰æœ‰æ•ˆç§»åŠ¨ï¼Œæ¸¸æˆç»“æŸï¼")
            break
        print(f"è‡ªåŠ¨ç§»åŠ¨ï¼š{move}")
        board = new_board
        add_random_tile(board)
        print_board(board)
        if reached_target(board) and not has_printed_win:
            print("å·²è¾¾åˆ° 2048ï¼ç»§ç»­è‡ªåŠ¨ç§»åŠ¨ä»¥è·å¾—æ›´é«˜åˆ†æ•°ã€‚")
            has_printed_win = True
        time.sleep(0.0001)

if __name__ == "__main__":
    main()
```

---

è¯´æ˜

1. **å‰ªæä¿®æ­£ï¼š**  
   - åœ¨ç©å®¶èŠ‚ç‚¹ä¸­æ›´æ–° alpha å¹¶è¿›è¡Œå‰ªæï¼›  
   - åœ¨ chance èŠ‚ç‚¹ä¸­ä¸æ›´æ–° betaï¼Œä¹Ÿä¸è¿›è¡Œå‰ªæï¼Œè€Œæ˜¯è®¡ç®—æ‰€æœ‰å¯èƒ½ç»“æœçš„å¹³å‡å€¼ã€‚

2. **åŠ¨æ€æœç´¢æ·±åº¦ï¼š**  
   - æ ¹æ®ç©ºæ ¼æ•°è¿”å›æœç´¢æ·±åº¦ 4ã€5 æˆ– 6ã€‚

3. **å…¶å®ƒä¼˜åŒ–ï¼š**  
   - è¯„ä¼°å‡½æ•°ç»“åˆäº†æƒé‡çŸ©é˜µã€ç©ºæ ¼å¥–åŠ±ã€å¹³æ»‘åº¦å’Œå•è°ƒæ€§ã€‚  
   - ä½¿ç”¨ LRU ç¼“å­˜é˜²æ­¢å†…å­˜æ— é™å¢é•¿ã€‚



æ•ˆæœä¸€æ ·ï¼ŒC8è¿è¡Œæ—¶é—´åº”è¯¥æ›´çŸ­ã€‚

<img src="https://raw.githubusercontent.com/GMyhf/img/main/img/image-20250227232724861.png" alt="image-20250227232724861" style="zoom:50%;" />





# é™„å½•

## Q. vi é‡Œé¢å¦‚ä½•æ‹·è´æ•´ä¸ªæ–‡ä»¶?

åœ¨Viæˆ–Vimç¼–è¾‘å™¨ä¸­ï¼Œæ‹·è´æ•´ä¸ªæ–‡ä»¶çš„å†…å®¹å¯ä»¥é€šè¿‡ä»¥ä¸‹æ­¥éª¤å®ç°ï¼š

### æ–¹æ³•ä¸€ï¼šä½¿ç”¨Vimå‘½ä»¤

1. æ‰“å¼€ä½ çš„æ–‡ä»¶ï¼š
   ```bash
   vim yourfile.txt
   ```

2. è¿›å…¥å‘½ä»¤æ¨¡å¼ï¼ˆæŒ‰ `Esc` é”®ç¡®ä¿ä½ åœ¨å‘½ä»¤æ¨¡å¼ä¸‹ï¼‰ã€‚

3. è¾“å…¥ä»¥ä¸‹å‘½ä»¤ä»¥é€‰ä¸­æ•´ä¸ªæ–‡ä»¶çš„æ–‡æœ¬ï¼š
   ```
   ggVG
   ```
   - `gg` å°†å…‰æ ‡ç§»åŠ¨åˆ°æ–‡ä»¶çš„ç¬¬ä¸€è¡Œã€‚
   - `V` è¿›å…¥å¯è§†è¡Œé€‰æ‹©æ¨¡å¼ã€‚
   - `G` é€‰æ‹©ä»å½“å‰è¡Œåˆ°æ–‡ä»¶æœ«å°¾çš„æ‰€æœ‰è¡Œï¼Œç»„åˆèµ·æ¥å°±æ˜¯å…¨é€‰æ•´ä¸ªæ–‡ä»¶ã€‚

4. å¤åˆ¶é€‰ä¸­çš„å†…å®¹ï¼ˆåœ¨å‘½ä»¤æ¨¡å¼ä¸‹ï¼‰ï¼š
   ```
   y
   ```
   è¿™é‡Œçš„ `y` æ˜¯ yank çš„ç¼©å†™ï¼Œç”¨äºå¤åˆ¶é€‰ä¸­çš„æ–‡æœ¬ã€‚

5. ç°åœ¨ï¼Œæ–‡ä»¶çš„æ‰€æœ‰å†…å®¹å·²ç»è¢«å¤åˆ¶åˆ°äº†Vimçš„å¯„å­˜å™¨ä¸­ã€‚ä½ å¯ä»¥é€šè¿‡æ‰“å¼€å¦ä¸€ä¸ªæ–‡ä»¶æˆ–è€…åœ¨åŒä¸€æ–‡ä»¶ä¸­ä¸åŒçš„ä½ç½®ç²˜è´´è¿™äº›å†…å®¹ï¼š
   - æ‰“å¼€æ–°æ–‡ä»¶è¿›è¡Œç²˜è´´ï¼š
     ```bash
     :e newfile.txt
     ```
     åœ¨æ–°æ–‡ä»¶ä¸­ï¼Œè¿›å…¥æ’å…¥æ¨¡å¼å‰æŒ‰ `p` é”®ç²˜è´´å†…å®¹ã€‚

### æ–¹æ³•äºŒï¼šç›´æ¥ä½¿ç”¨ç³»ç»Ÿå‰ªè´´æ¿ï¼ˆå¦‚æœæ”¯æŒï¼‰

å¦‚æœä½ çš„Vimç‰ˆæœ¬æ”¯æŒä¸ç³»ç»Ÿå‰ªè´´æ¿äº¤äº’ï¼Œå¹¶ä¸”ä½ æ­£åœ¨ä½¿ç”¨å›¾å½¢ç•Œé¢ç‰ˆæœ¬çš„Vimï¼ˆå¦‚gvimï¼‰ï¼Œå¯ä»¥ç›´æ¥å°†æ–‡ä»¶å†…å®¹å‘é€åˆ°ç³»ç»Ÿå‰ªè´´æ¿ï¼š

1. åœ¨æ­£å¸¸æ¨¡å¼ä¸‹è¾“å…¥ä»¥ä¸‹å‘½ä»¤æ¥é€‰æ‹©å¹¶å¤åˆ¶æ•´ä¸ªæ–‡ä»¶è‡³ç³»ç»Ÿå‰ªè´´æ¿ï¼š
   ```
   :%y+
   ```
   è¿™é‡Œçš„ `%` è¡¨ç¤ºæ•´ä¸ªæ–‡ä»¶èŒƒå›´ï¼Œ`y+` è¡¨ç¤ºå°†é€‰ä¸­çš„å†…å®¹å¤åˆ¶åˆ°ç³»ç»Ÿå‰ªè´´æ¿ã€‚

2. ç„¶åä½ å¯ä»¥åˆ‡æ¢åˆ°å…¶ä»–åº”ç”¨ç¨‹åºä¸­ç²˜è´´è¿™ä¸ªå†…å®¹ã€‚

è¯·æ³¨æ„ï¼Œå¯¹äºæ–¹æ³•äºŒï¼Œéœ€è¦ç¡®ä¿ä½ çš„Vimå®‰è£…äº†å¯¹ç³»ç»Ÿå‰ªè´´æ¿çš„æ”¯æŒï¼ˆé€šå¸¸éœ€è¦`+clipboard`ç‰¹æ€§ï¼‰ã€‚å¯ä»¥é€šè¿‡è¿è¡Œ `vim --version | grep clipboard` æ¥æ£€æŸ¥æ˜¯å¦æ”¯æŒã€‚å¦‚æœè¾“å‡ºä¸­æœ‰ `+clipboard` åˆ™è¡¨ç¤ºæ”¯æŒï¼Œå¦‚æœæœ‰ `-clipboard` åˆ™ä¸æ”¯æŒï¼Œè¿™ç§æƒ…å†µä¸‹å¯èƒ½éœ€è¦å®‰è£…é¢å¤–çš„åŒ…æˆ–ä½¿ç”¨å¦ä¸€ç§æ–¹æ³•ã€‚



## Q.Alpha-Betaå‰ªæçš„åŸºæœ¬åŸç†

Alpha-Betaå‰ªææ˜¯ä¸€ç§ç”¨äºåšå¼ˆæ ‘æœç´¢çš„ä¼˜åŒ–æŠ€æœ¯ï¼Œç›®çš„æ˜¯å‡å°‘è¯„ä¼°èŠ‚ç‚¹çš„æ•°é‡ï¼Œä»è€Œæé«˜Minimaxç®—æ³•çš„æ•ˆç‡ã€‚å®ƒé€šè¿‡å¿½ç•¥é‚£äº›ä¸ä¼šå½±å“æœ€ç»ˆå†³ç­–çš„éƒ¨åˆ†æœç´¢æ ‘æ¥å®ç°è¿™ä¸€ç‚¹ã€‚ä¸‹é¢æ˜¯Alpha-Betaå‰ªæçš„åŸºæœ¬åŸç†çš„ç®€è¦è¯´æ˜ã€‚

### 1. æ ¸å¿ƒæ¦‚å¿µ
ä¸è¦æ­»è®°ç¡¬èƒŒ Alpha å’Œ Betaï¼Œè¯·è¿™æ ·ç†è§£ï¼š
*   **Maxï¼ˆä½ ï¼‰**ï¼šæƒ³è¦åˆ†æ•°è¶Šé«˜è¶Šå¥½ã€‚
*   **Minï¼ˆå¯¹æ‰‹ï¼‰**ï¼šæƒ³è¦åˆ†æ•°è¶Šä½è¶Šå¥½ã€‚
*   **Alphaï¼ˆ$\alpha$ï¼‰**ï¼š**ä½ çš„åº•çº¿**ã€‚æ„æ€æ˜¯â€œæˆ‘ç°åœ¨æ‰‹é‡Œå·²ç»ç¨³æ‹¿ X åˆ†äº†ï¼Œæ›´çƒ‚çš„æˆ‘ä¸è¦â€ã€‚
*   **Betaï¼ˆ$\beta$ï¼‰**ï¼š**å¯¹æ‰‹çš„åº•çº¿**ï¼ˆä¹Ÿæ˜¯ä½ çš„å¤©èŠ±æ¿ï¼‰ã€‚æ„æ€æ˜¯â€œå¯¹æ‰‹å·²ç»èƒ½æŠŠåˆ†å‹åˆ° Y åˆ†äº†ï¼Œå¦‚æœæˆ‘è¿™è¾¹ç®—å‡ºä¸ªæ¯” Y æ›´é«˜çš„åˆ†ï¼Œå¯¹æ‰‹ç»ä¸ä¼šè®©æˆ‘èµ°è¿™æ¡è·¯â€ã€‚

### 2. æ ‘å½¢å›¾è¡¨ç¤º
å‡è®¾æˆ‘ä»¬æœ‰è¿™æ ·ä¸€æ£µæ ‘ã€‚
*   **ç¬¬ä¸€å±‚ï¼ˆMaxï¼‰**ï¼šè½®åˆ°ä½ èµ°ã€‚
*   **ç¬¬äºŒå±‚ï¼ˆMinï¼‰**ï¼šè½®åˆ°å¯¹æ‰‹èµ°ã€‚
*   **ç¬¬ä¸‰å±‚ï¼ˆæ•°å­—ï¼‰**ï¼šæœ€ç»ˆçš„å¾—åˆ†ã€‚

æˆ‘ä»¬æŒ‰ç…§**ä»å·¦åˆ°å³**çš„é¡ºåºè®¡ç®—ã€‚

```text
             [Max: æ ¹èŠ‚ç‚¹]
           /       |       \
        (A)       (B)      (C)    <-- å¯¹æ‰‹(Min)å±‚
       /   \     /   \    /   \
      3     5   2    ?   9    ?
```

### 3. å‰ªæè¿‡ç¨‹è¯¦è§£ï¼ˆä¸€æ­¥æ­¥çœ‹ï¼‰

**ç¬¬ä¸€æ­¥ï¼šæ¢ç´¢å·¦è¾¹åˆ†æ”¯ (A)**
1.  ç”µè„‘å…ˆçœ‹å·¦è¾¹ã€‚å¯¹æ‰‹(Min)åœ¨ A èŠ‚ç‚¹é¢ä¸´ä¸¤ä¸ªé€‰æ‹©ï¼š3 å’Œ 5ã€‚
2.  å¯¹æ‰‹å¾ˆèªæ˜ï¼Œè‚¯å®šé€‰å°çš„ã€‚æ‰€ä»¥ **A èŠ‚ç‚¹çš„ä»·å€¼æ˜¯ 3**ã€‚
3.  **æ›´æ–° Alphaï¼ˆä½ çš„åº•çº¿ï¼‰**ï¼šè¿™æ—¶å€™ä½ ï¼ˆMaxï¼‰çŸ¥é“äº†ï¼Œèµ°å·¦è¾¹è¿™ä¸€è·¯ï¼Œ**æœ€å·®ä¹Ÿèƒ½å¾— 3 åˆ†**ã€‚
    *   å½“å‰ **$\alpha = 3$**ã€‚

**ç¬¬äºŒæ­¥ï¼šæ¢ç´¢ä¸­é—´åˆ†æ”¯ (B) â€”â€” ã€å‰ªæå‘ç”Ÿæ—¶åˆ»ï¼ã€‘**
1.  ç”µè„‘å¼€å§‹è®¡ç®— B èŠ‚ç‚¹ã€‚
2.  å…ˆçœ‹äº† B çš„ç¬¬ä¸€ä¸ªå­èŠ‚ç‚¹ï¼š**æ˜¯ 2**ã€‚
3.  **åœï¼æ€è€ƒä¸€ä¸‹ï¼š**
    *   å¯¹æ‰‹(Min)åœ¨ B èŠ‚ç‚¹ï¼Œå‘ç°äº†ä¸€ä¸ª 2ã€‚å› ä¸ºå¯¹æ‰‹æƒ³è¦åˆ†è¶Šä½è¶Šå¥½ï¼Œæ‰€ä»¥ä¸ç®¡ B åé¢é‚£ä¸ªé—®å·ï¼ˆ?ï¼‰æ˜¯å¤šå°‘ï¼ˆå“ªæ€•æ˜¯ 0 æˆ– -100ï¼‰ï¼Œå¯¹æ‰‹åœ¨ B è¿™ä¸€è·¯çš„é€‰æ‹©**ç»å¯¹ä¸ä¼šè¶…è¿‡ 2**ã€‚
    *   ä¹Ÿå°±æ˜¯ï¼š**B èŠ‚ç‚¹çš„æœ€ç»ˆä»·å€¼ $\le$ 2**ã€‚
4.  **ä¸ä½ çš„åº•çº¿å¯¹æ¯”**ï¼š
    *   ä½ ï¼ˆMaxï¼‰æ‰‹é‡Œå·²ç»æ¡ç€å·¦è¾¹çš„ **3åˆ†**ï¼ˆAlpha=3ï¼‰ã€‚
    *   è€Œä¸­é—´è¿™æ¡è·¯ï¼ˆBï¼‰ï¼Œå¯¹æ‰‹æœ€ä»æ…ˆä¹Ÿåªä¼šè®©ä½ å¾— **2åˆ†**ã€‚
5.  **ç»“è®º**ï¼šä½ æ˜¯ä¸ªæ­£å¸¸äººï¼Œæ—¢ç„¶å·¦è¾¹èƒ½å¾—3åˆ†ï¼Œä½ ç»ä¸ä¼šé€‰åªèƒ½å¾—2åˆ†çš„ä¸­é—´è¿™æ¡è·¯ã€‚
6.  **å‰ªæ**ï¼šB èŠ‚ç‚¹åé¢å‰©ä¸‹çš„é‚£ä¸ªé—®å·ï¼ˆ?ï¼‰ï¼Œ**æ ¹æœ¬ä¸ç”¨ç®—äº†ï¼** ç›´æ¥ç æ‰ã€‚

**ç¬¬ä¸‰æ­¥ï¼šæ¢ç´¢å³è¾¹åˆ†æ”¯ (C)**

1.  ç”µè„‘å¼€å§‹è®¡ç®— C èŠ‚ç‚¹ã€‚
2.  å…ˆçœ‹äº† C çš„ç¬¬ä¸€ä¸ªå­èŠ‚ç‚¹ï¼š**æ˜¯ 9**ã€‚
3.  **æ€è€ƒ**ï¼š
    *   å¯¹æ‰‹(Min)åœ¨ C èŠ‚ç‚¹çœ‹åˆ° 9ã€‚å¯¹æ‰‹è¿˜åœ¨æ‰¾æœ‰æ²¡æœ‰æ¯” 9 æ›´å°çš„æ•°ã€‚
    *   ç›®å‰ C çš„ä»·å€¼ $\le$ 9ã€‚
4.  **ä¸ä½ çš„åº•çº¿å¯¹æ¯”**ï¼š
    *   ä½ çš„åº•çº¿ Alpha æ˜¯ 3ã€‚
    *   ç›®å‰ C è¿™æ¡è·¯æœ‰å¯èƒ½ç»™ä½  9 åˆ†ï¼ˆå¦‚æœå¯¹æ‰‹åé¢æ²¡åˆ«çš„æ‹›ï¼‰ã€‚
    *   $9 > 3$ï¼Œè¿™æ¯”ä½ ç°åœ¨çš„åº•çº¿å¥½ï¼æ‰€ä»¥**ä¸èƒ½å‰ªæ**ï¼Œå¿…é¡»ç»§ç»­çœ‹ C åé¢çš„é—®å·ï¼ˆ?ï¼‰ï¼Œä¸‡ä¸€åé¢æ˜¯ä¸ª 1 å‘¢ï¼Ÿé‚£å¯¹æ‰‹è‚¯å®šé€‰ 1ï¼Œä½ å°±å¾—ä¸åˆ° 9 äº†ã€‚
5.  æ‰€ä»¥ C åˆ†æ”¯å¿…é¡»ç®—å®Œã€‚



### æ€»ç»“åŸç†

ä¸Šé¢çš„è¿‡ç¨‹ç¿»è¯‘æˆâ€œå‰ªæåŸç†â€å°±æ˜¯ï¼š

1.  **Alpha å‰ªæï¼ˆå‘ç”Ÿåœ¨ Min èŠ‚ç‚¹ï¼Œå¦‚ Bï¼‰**ï¼š
    *   å½“**å¯¹æ‰‹(Min)** å‘ç°è¿™ä¸€æ­¥å¦‚æœèµ°ä¸‹å»ï¼Œåˆ†æ•°æ¯” **ä½ (Max)** å·²ç»æ‹¥æœ‰çš„åº•çº¿ï¼ˆAlphaï¼‰è¿˜è¦ä½ã€‚
    *   **Max å¿ƒé‡Œè¯**ï¼šâ€œè¿™è·¯å¤ªçƒ‚äº†ï¼Œæ¯”æˆ‘åˆšæ‰æ‰¾çš„è·¯è¿˜çƒ‚ï¼Œæˆ‘ä¸å¯èƒ½èµ°è¿™å„¿ï¼Œåˆ«ç®—äº†ã€‚â€ -> **å‰ªæ‰ï¼**

2.  **Beta å‰ªæï¼ˆå‘ç”Ÿåœ¨ Max èŠ‚ç‚¹ï¼Œåè¿‡æ¥ï¼‰**ï¼š
    *   å½“ **ä½ (Max)** å‘ç°è¿™ä¸€æ­¥å¦‚æœèµ°ä¸‹å»ï¼Œåˆ†æ•°æ¯” **å¯¹æ‰‹(Min)** å·²ç»è®¾ä¸‹çš„é™åˆ¶ï¼ˆBetaï¼‰è¿˜è¦é«˜ã€‚
    *   **Min å¿ƒé‡Œè¯**ï¼šâ€œä½ æƒ³å¾—ç¾ï¼åˆšæ‰æˆ‘å·²ç»æ‰¾åˆ°è®©ä½ åªèƒ½å¾—5åˆ†çš„åŠæ³•ï¼Œç°åœ¨ä½ æƒ³èµ°è¿™æ¡å¾—100åˆ†çš„è·¯ï¼Ÿæˆ‘ç»ä¸ä¼šè®©ä½ èµ°åˆ°è¿™ä¸ªèŠ‚ç‚¹çš„ã€‚â€ -> **å‰ªæ‰ï¼**



**è®°ä½ä¸€å¥è¯ï¼š**
**å‰ªæå°±æ˜¯å› ä¸ºâ€œå·²ç»æœ‰ä¸€æ¡æ›´å¥½çš„é€€è·¯ï¼ˆå¯¹ Max æ¥è¯´ï¼‰â€æˆ–è€…â€œå¯¹æ‰‹å·²ç»æŠ“ä½äº†ä½ çš„æŠŠæŸ„ï¼ˆå¯¹ Min æ¥è¯´ï¼‰â€ï¼Œå¯¼è‡´å½“å‰çš„æ¢ç´¢å˜å¾—æ¯«æ— æ„ä¹‰ã€‚**

é€šè¿‡è¿™ç§æ–¹å¼ï¼ŒAlpha-Betaå‰ªæèƒ½å¤Ÿåœ¨ä¸æ”¹å˜æœ€ç»ˆç»“æœçš„æƒ…å†µä¸‹æ˜¾è‘—å‡å°‘éœ€è¦è¯„ä¼°çš„èŠ‚ç‚¹æ•°ï¼Œç‰¹åˆ«æ˜¯åœ¨ç†æƒ³æƒ…å†µä¸‹ï¼ˆæ¯”å¦‚å¯¹æ‰‹çš„æœ€ä½³ç§»åŠ¨æ€»æ˜¯æœ€å…ˆè¢«è€ƒå¯Ÿï¼‰ï¼Œå®ƒå¯ä»¥å°†æœç´¢æ•ˆç‡æé«˜ä¸€å€ã€‚
